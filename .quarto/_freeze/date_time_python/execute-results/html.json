{
  "hash": "b5375274039b10a3ba15fa6fb148a89f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Handling date time in python\"\n# author: dsfe\nformat: \n  revealjs:\n    height: 1080\n    width: 1920\n    slide-number: true\n    theme: theme/dsfe_theme.scss\n    code-copy: false\n    logo: logo/dsfe_logo.svg\n    footer: \"Data Science For Everyone\"\njupyter: python3\nhighlight-style: \"dracula\"\nbrand: brand/_dsfe_brand.yml\nexecute: \n  echo: true\n---\n\n## Date in python\n\n::: notes\nWelcome to data science for everyone. Today I’ll be guiding you through this course on handling dates and times in Python. Dates are everywhere in data science—whether it's tracking stock market changes, running experiments, recording birthdays, or analyzing political events. All of these happen at specific points in time. Being able to work with time-based data is a fundamental skill for any data scientist.\n\nPython includes a special class for working with dates, called date. It’s similar to other data types like strings, numbers, or arrays—it has its own rules for how to create it and methods for using it. In this lesson, we’ll focus on how to create date objects and how to pull basic information from them.\n:::\n\n## Please like, comment, and subscribe if you like my videos\n\n![](assets/subscribe.png)\n\n## Date in python\n\n::: {#c808ae68 .cell execution_count=1}\n``` {.python .cell-code}\ndates = [\"12/03/2025\", \"11/05/2025\"]\n```\n:::\n\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nSo, why do we need a separate class just for dates? Let’s find out. In this chapter, you’ll work with 67 years of hurricane landfall data in Florida. You’ll start with a list called two_hurricanes, which includes the dates of two hurricanes stored as strings—one from October 7th, 2016, and another from June 21st, 2017. These dates follow the U.S. format: month, day, year.\n\nNow imagine trying to answer a few questions:\n\nHow many days passed between these two hurricanes?\n\nAre they listed in the correct chronological order?\n\nWhat day of the week did each one happen?\n\nDoing this manually would be tedious. But with Python, it’s simple. By the end of this chapter, you’ll know exactly how to do all of these things.\n:::\n\n## Creating date objects\n\n::: {#c7ff784e .cell execution_count=2}\n``` {.python .cell-code}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\n```\n:::\n\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nTo start working with dates, we first need to import the date class. All date and time-related classes live inside Python’s datetime module. We create a date using the date() function.\n\nHere’s how we turn our two hurricane dates into Python date objects. The date() function takes three arguments: year, month, and day—in that order. So for October 7, 2016, we write date(2016, 10, 7), and for June 21, 2017, we write date(2017, 6, 21). It’s a simple format: from largest to smallest—year, then month, then day.\n\nLater on, we’ll see how to convert strings into dates, but for now, we’ll stick to creating them manually or using pre-made lists.\n:::\n\n## Accessing date components\n\n::: {#c1c62ec9 .cell execution_count=3}\n``` {.python .cell-code}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\nprint(dates[0].year)\nprint(dates[0].month)\nprint(dates[0].day)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025\n3\n12\n```\n:::\n:::\n\n\n::: notes\nOnce you have a date object, you can easily get its individual parts. Want the year? Just use .year. Need the month or day? Use .month and .day. It’s straightforward and easy to remember.\n:::\n\n## Finding the weekday\n\n::: {#2c650cdb .cell execution_count=4}\n``` {.python .cell-code}\nprint(dates[0].weekday())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n```\n:::\n:::\n\n\n::: white-text\n0 = Monday 1 = Tuesday ... 6 = Sunday What are the days of the week?\n:::\n\n::: notes\nPython can also help with more complex tasks. For example, to find out what day of the week a date falls on, you can use the .weekday() method. This method returns a number from 0 to 6, where 0 is Monday, 1 is Tuesday, and so on—up to 6, which is Sunday. So if .weekday() returns 4, that means the date is a Friday.\n:::\n\n## Understanding date math\n\n::: {#b992402e .cell execution_count=5}\n``` {.python .cell-code}\na = 21\nb = 24\nlist = [a, b]\nprint(max(list))\nprint(a - b)\nprint(a + 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n24\n-3\n31\n```\n:::\n:::\n\n\n::: notes\nToday, we’re going to explore how to do math with dates. That means things like figuring out how many days are between two dates, moving a date forward or backward, and comparing which date comes first. Let’s go back to something familiar: simple math with numbers. If we pick two numbers—say 21 and 24—we can use Python to figure out which one is smaller. We’ll store them as variables and place them into a list. Then, using the max() function, Python will return the smallest one. In our case, that’s 21. We can perform mathematical operations on the numbers as well.\n:::\n\n## Turning numbers into dates\n\n::: {#51c7e229 .cell execution_count=6}\n``` {.python .cell-code}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\ndate2 = date(2025, 5, 11)\ndate_list = [date1, date2]\nprint(max(date_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-05-11\n```\n:::\n:::\n\n\n::: notes\nNow let’s switch from numbers to dates. We’ll use the date class from Python’s datetime module. We create two date objects: one for each of these dates. We can then put these into a list and use the max() function again. This time, it tells us which date comes first.\n:::\n\n## Subtracting dates\n\n::: {#81625449 .cell execution_count=7}\n``` {.python .cell-code}\ndate_sub = date2 - date1\ndate_sub.days\n```\n\n::: {.cell-output .cell-output-display execution_count=395}\n```\n60\n```\n:::\n:::\n\n\n::: {#3979b28b .cell execution_count=8}\n``` {.python .cell-code}\ntype(date_sub)\n```\n\n::: {.cell-output .cell-output-display execution_count=396}\n```\ndatetime.timedelta\n```\n:::\n:::\n\n\n::: notes\nJust like numbers, we can subtract one date from another. If we subtract March 10th from April 8th, Python gives us something called a timedelta object. This object tells us the difference between the two dates. If we check its .days attribute, we’ll see how many days are in between—in this case, 29.\n:::\n\n## Adding time to dates\n\n::: {#67ea9530 .cell execution_count=9}\n``` {.python .cell-code}\nfrom datetime import timedelta\ntd = timedelta(days = 10)\nprint(date1 + td)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-03-22\n```\n:::\n:::\n\n\n::: notes\nWe can also go the other way: we can add days to a date. To do that, we import timedelta, then create a 29-day time span. If we add that to March 10th, Python gives us April 8th. It takes care of counting the days in each month automatically—no need to remember how many days are in March!\n:::\n\n## The ISO 8601 format\n\n::: {#98d64880 .cell execution_count=10}\n``` {.python .cell-code}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\nprint(date1) # ISO format (YYYY-MM-DD)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-03-12\n```\n:::\n:::\n\n\n::: {#193e7f7d .cell execution_count=11}\n``` {.python .cell-code}\nprint([date1.isoformat()])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['2025-03-12']\n```\n:::\n:::\n\n\n::: notes\nPython makes it easy to turn date objects into strings that are easier to read or use. This is helpful when you want to display a date on the screen, include it in a file name, or save it in a CSV or Excel file. Let’s start with how Python shows a date by default. We'll import date from datetime and create a date for July 15, 2022. When we print this date, Python shows it like this: 2022-07-15. That’s year first, then month, then day — all separated by dashes. This format is known as ISO 8601. It's standardized, and always uses two digits for the month and day, even if they're below 10. If we want to get this date as a string — say, to save in a CSV file — we can use the .isoformat() method.\n:::\n\n## Why ISO 8601 is useful\n\n::: {#dac290d3 .cell execution_count=12}\n``` {.python .cell-code}\ndates_list = [\"2001-09-25\", \"2003-02-10\"]\nprint(sorted(dates_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['2001-09-25', '2003-02-10']\n```\n:::\n:::\n\n\n::: notes\nOne big advantage of ISO 8601 is that it sorts dates properly when they’re in string format. Let’s say we have two dates as strings: “2003-02-10” and “2001-09-25”. If we put them in a list and sort it, they’ll be ordered from oldest to newest. That’s because ISO 8601 format puts the biggest unit (year) first, followed by month and day. This makes it really useful for naming files in a way that keeps them in chronological order.\n:::\n\n## Other date formats\n\n::: {#cc293584 .cell execution_count=13}\n``` {.python .cell-code}\nd.strftime()\n```\n:::\n\n\n::: notes\nIf you don’t want to use the ISO format, Python gives you other options. You can use the strftime() method to format dates however you want.\n:::\n\n## Using `strftime` to format dates\n\n::: {#ed7c4c64 .cell execution_count=14}\n``` {.python .cell-code}\ndate3 = date(2021, 4, 3)\nprint(date3.strftime(\"%Y\"))\nprint(date3.strftime(\"%m\"))\nprint(date3.strftime(\"The month is %m.\"))\nprint(date3.strftime(\"%m/%d/%Y\"))\nprint(date3.strftime(\"%Y-%j\")) # format 'YYYY-DDD'\nprint(date3.strftime(\"%B (%Y)\")) # format 'MONTH (YYYY)'\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2021\n04\nThe month is 04.\n04/03/2021\n2021-093\nApril (2021)\n```\n:::\n:::\n\n\n::: notes\nThe strftime() method lets you create a string version of a date using a format code. Let’s create a date for April 3, 2021. If we use strftime(\"%Y\"), Python gives us just the year: “2021”. You can include this in a longer string too — for example, \"Year: %Y\" would return \"Year: 2021\". There are more format codes too. %m gives you the month as a number, and %d gives you the day. So \"%m/%d/%Y\" would return something like \"04/03/2021\". You can combine these in any way you like to match the format you need.\n:::\n\n## Combining dates and times\n\n::: {#0f1b2e5e .cell execution_count=15}\n``` {.python .cell-code}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14)\n```\n:::\n\n\n::: notes\nSo far, we've only been working with dates. Now, it's time to bring in the concept of time — not just the day, but the hour, minute, and second within that day.\nLet’s look at an example: imagine something happened on March 14, 2022, at 3:45:10 PM. Instead of just storing the date, we want to include the exact time. Let’s see how we can represent this in Python.\nTo work with both dates and times, we need to import the datetime class from the datetime module. Yes, both are called “datetime.” It’s a bit confusing at first, but you’ll get used to it quickly.\nLet’s make a new datetime object and store it in a variable called dt. We’ll give it all the information it needs right when we create it.\nThe first three values we pass in are the same as when we create a date object — the year, followed by the month, then the day. All as numbers.\n:::\n\n## Adding the hour\n\n::: {#01fdb2ab .cell execution_count=16}\n``` {.python .cell-code}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\n```\n:::\n\n\n::: notes\nAfter the day, we add the hour. Python uses 24-hour time by default, so 3 PM would be 15.\nNext, we enter the minutes — in this case, 45. Remember, there are 60 minutes in an hour.\nFinally, we include the seconds. So, for 10 seconds past the minute, we add 10 as the last argument. Our full datetime now includes all six parts: year, month, day, hour, minute, and second.\n:::\n\n## Including microseconds\n\n::: {#606c1a30 .cell execution_count=17}\n``` {.python .cell-code}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10, 250000)\n\n# explicit named arguments\ndt = datetime(year = 2022, month = 3, day = 14, \n              hour = 15, minute = 45, second = 10, \n              microsecond = 250000)\n```\n:::\n\n\n::: notes\nIf you need more precision, you can add microseconds. For example, adding 250,000 microseconds means the time is 0.25 seconds past 9:45:10. Python can track time down to millionths of a second — and if you need even more precision, like nanoseconds, we’ll cover that when we get to Pandas.\nThat's a lot to remember, so if it helps, you can use named arguments like year=2022, month=3, and so on. This makes your code easier to read and reduces the chance of mistakes.\n:::\n\n## Modifying a datetime\n\n::: {#a93240c5 .cell execution_count=18}\n``` {.python .cell-code}\nprint(dt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14 15:45:10.250000\n```\n:::\n:::\n\n\n::: {#f1aa16d9 .cell execution_count=19}\n``` {.python .cell-code}\ndt_new = dt.replace(minute = 22, microsecond = 500000)\nprint(dt_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14 15:22:10.500000\n```\n:::\n:::\n\n\n::: notes\nYou can also take an existing datetime and tweak it using the replace() method. For example, if you want to round a time down to the start of the hour, you can set minutes, seconds, and microseconds to zero. This gives you a new datetime, with the other values unchanged.\n:::\n\n## Example dataset: City scooter trips\n\n::: notes\nFor the rest of this course, we’ll use data from a scooter sharing service in Austin, Texas. Each record shows when a scooter was unlocked and when it was returned. We'll focus on one scooter, ID “X13456,” and track all its trips in the last three months of 2022. Each trip has a start and end datetime — perfect for practicing with date and time data.\n:::\n\n## Printing and parsing datetimes\n\n::: {#b8accb66 .cell execution_count=20}\n``` {.python .cell-code}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\nprint(dt.strftime(\"%Y-%m-%d\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14\n```\n:::\n:::\n\n\n::: {#b7ea5225 .cell execution_count=21}\n``` {.python .cell-code}\nprint(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14 15:45:10\n```\n:::\n:::\n\n\n::: {#fff7e62d .cell execution_count=22}\n``` {.python .cell-code}\nprint(dt.strftime(\"%Y-%m-%d %I:%M:%S %p\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14 03:45:10 PM\n```\n:::\n:::\n\n\n::: notes\nJust like dates, datetimes can be displayed in many different ways. Python can also take a string and turn it into a datetime. Let’s first look at how to format and print a datetime, then move on to how Python can read one from a string.\nWe’ll start by creating a datetime for March 14, 2022, at 3:45:10 PM. To turn this into a nicely formatted string, we’ll use strftime().\n\nFirst, we’ll print just the date using %Y for the full year, %m for the month, and %d for the day.\n\nNext, we’ll include the time using %H for hour (24-hour format), %M for minutes, and %S for seconds.\n\nYou can also use codes for 12-hour time and add AM or PM if needed. To convert your datetime to a 12-hour format with AM/PM, you can use the format codes %I for the hour (12-hour clock) and %p for AM/PM\n:::\n\n## ISO 8601 format\n\n::: {#6acf2d8d .cell execution_count=23}\n``` {.python .cell-code}\nprint(dt.isoformat())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2022-03-14T15:45:10\n```\n:::\n:::\n\n\n::: notes\nPython also has a built-in way to print a datetime in a standard format using isoformat().\n\nThis outputs the date and time as YYYY-MM-DDTHH:MM:SS, which is a widely accepted format and great to use when you’re unsure what format to pick.\n:::\n\n## Parsing datetimes with strptime\n\n::: {#ebd5f81a .cell execution_count=24}\n``` {.python .cell-code}\nfrom datetime import datetime\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m/%d/%Y %H:%M:%S\")\n```\n:::\n\n\n::: notes\nNow let’s turn a string into a datetime. This is useful when you get dates from text files, websites, or APIs.\n\nTo start, import the datetime class from the datetime module.\nThe function we’ll use is called strptime(), which means “string parse time.”\n\nIt takes two arguments: the string that contains the date and time, and a format string that tells Python how to read it.\nLet’s say we have a string like '10/12/2023 08:45:27'. That’s October 12, 2023 at 8:45:27 in the morning.\nNow we give Python the format it needs to understand the string.\n\nIn this case, the format would be '%m/%d/%Y %H:%M:%S'. This tells Python to expect a month, day, and year with slashes, followed by time separated by colons.\n\nUsually, once per dataset, you’ll figure out this format and reuse it.\n:::\n\n## Confirming the result\n\n::: {#0f4e535c .cell execution_count=25}\n``` {.python .cell-code}\nprint(type(dt2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'datetime.datetime'>\n```\n:::\n:::\n\n\n::: {#2d0bd5f6 .cell execution_count=26}\n``` {.python .cell-code}\nprint(dt2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-10-12 08:45:27\n```\n:::\n:::\n\n\n::: notes\nIf we check the type of the result, it’s a datetime object.\n\nAnd if we print it, Python shows a clean version of the datetime — proving it was parsed correctly.\n:::\n\n## When formats don’t match\n\n::: {#8f298ca9 .cell execution_count=27}\n``` {.python .cell-code}\nfrom datetime import datetime\n\n# Incorrect formatting\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m-%d-%Y %H:%M:%S\")\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\nCell <span class=\"ansi-green-fg\">In[414], line 4</span>\n<span class=\"ansi-green-fg ansi-bold\">      1</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">from</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,0,255)\">datetime</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"font-weight:bold;color:rgb(0,135,0)\">import</span> datetime\n<span class=\"ansi-green-fg ansi-bold\">      3</span> <span style=\"font-style:italic;color:rgb(95,135,135)\"># Incorrect formatting</span>\n<span class=\"ansi-green-fg\">----&gt; 4</span> dt2 <span style=\"color:rgb(98,98,98)\">=</span> datetime<span style=\"color:rgb(98,98,98)\">.</span>strptime(<span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">10/12/2023 08:45:27</span><span style=\"color:rgb(175,0,0)\">\"</span>,\n<span class=\"ansi-green-fg ansi-bold\">      5</span>                         <span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">m-</span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%d</span><span style=\"color:rgb(175,0,0)\">-</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">Y </span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">H:</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">M:</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">S</span><span style=\"color:rgb(175,0,0)\">\"</span>)\n\nFile <span class=\"ansi-green-fg\">~/anaconda3/lib/python3.13/_strptime.py:673</span>, in <span class=\"ansi-cyan-fg\">_strptime_datetime</span><span class=\"ansi-blue-fg\">(cls, data_string, format)</span>\n<span class=\"ansi-green-fg ansi-bold\">    670</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span style=\"color:rgb(0,0,255)\">_strptime_datetime</span>(<span style=\"color:rgb(0,135,0)\">cls</span>, data_string, <span style=\"color:rgb(0,135,0)\">format</span><span style=\"color:rgb(98,98,98)\">=</span><span style=\"color:rgb(175,0,0)\">\"</span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%a</span><span style=\"color:rgb(175,0,0)\"> </span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">b </span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%d</span><span style=\"color:rgb(175,0,0)\"> </span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">H:</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">M:</span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">S </span><span style=\"color:rgb(175,0,0)\">%</span><span style=\"color:rgb(175,0,0)\">Y</span><span style=\"color:rgb(175,0,0)\">\"</span>):\n<span class=\"ansi-green-fg ansi-bold\">    671</span> <span style=\"color:rgb(188,188,188)\">    </span><span style=\"font-style:italic;color:rgb(175,0,0)\">\"\"\"Return a class cls instance based on the input string and the</span>\n<span class=\"ansi-green-fg ansi-bold\">    672</span> <span style=\"font-style:italic;color:rgb(175,0,0)\">    format string.\"\"\"</span>\n<span class=\"ansi-green-fg\">--&gt; 673</span>     tt, fraction, gmtoff_fraction <span style=\"color:rgb(98,98,98)\">=</span> _strptime(data_string, <span style=\"color:rgb(0,135,0)\">format</span>)\n<span class=\"ansi-green-fg ansi-bold\">    674</span>     tzname, gmtoff <span style=\"color:rgb(98,98,98)\">=</span> tt[<span style=\"color:rgb(98,98,98)\">-</span><span style=\"color:rgb(98,98,98)\">2</span>:]\n<span class=\"ansi-green-fg ansi-bold\">    675</span>     args <span style=\"color:rgb(98,98,98)\">=</span> tt[:<span style=\"color:rgb(98,98,98)\">6</span>] <span style=\"color:rgb(98,98,98)\">+</span> (fraction,)\n\nFile <span class=\"ansi-green-fg\">~/anaconda3/lib/python3.13/_strptime.py:452</span>, in <span class=\"ansi-cyan-fg\">_strptime</span><span class=\"ansi-blue-fg\">(data_string, format)</span>\n<span class=\"ansi-green-fg ansi-bold\">    450</span> found <span style=\"color:rgb(98,98,98)\">=</span> format_regex<span style=\"color:rgb(98,98,98)\">.</span>match(data_string)\n<span class=\"ansi-green-fg ansi-bold\">    451</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">if</span> <span style=\"font-weight:bold;color:rgb(175,0,255)\">not</span> found:\n<span class=\"ansi-green-fg\">--&gt; 452</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">raise</span> <span style=\"font-weight:bold;color:rgb(215,95,95)\">ValueError</span>(<span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">time data </span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%r</span><span style=\"color:rgb(175,0,0)\"> does not match format </span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%r</span><span style=\"color:rgb(175,0,0)\">\"</span> <span style=\"color:rgb(98,98,98)\">%</span>\n<span class=\"ansi-green-fg ansi-bold\">    453</span>                      (data_string, <span style=\"color:rgb(0,135,0)\">format</span>))\n<span class=\"ansi-green-fg ansi-bold\">    454</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">if</span> <span style=\"color:rgb(0,135,0)\">len</span>(data_string) <span style=\"color:rgb(98,98,98)\">!=</span> found<span style=\"color:rgb(98,98,98)\">.</span>end():\n<span class=\"ansi-green-fg ansi-bold\">    455</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">raise</span> <span style=\"font-weight:bold;color:rgb(215,95,95)\">ValueError</span>(<span style=\"color:rgb(175,0,0)\">\"</span><span style=\"color:rgb(175,0,0)\">unconverted data remains: </span><span style=\"font-weight:bold;color:rgb(175,95,135)\">%s</span><span style=\"color:rgb(175,0,0)\">\"</span> <span style=\"color:rgb(98,98,98)\">%</span>\n<span class=\"ansi-green-fg ansi-bold\">    456</span>                       data_string[found<span style=\"color:rgb(98,98,98)\">.</span>end():])\n\n<span class=\"ansi-red-fg\">ValueError</span>: time data '10/12/2023 08:45:27' does not match format '%m-%d-%Y %H:%M:%S'</pre>\n```\n:::\n\n:::\n:::\n\n\n::: notes\nThe format must exactly match the string.\n\nIf you forget to include the time, or if there’s an extra comma or symbol in the string, Python will throw an error. Always check that your format and string align.\n:::\n\n## Working with Unix timestamps\n\n::: {#1e16e32c .cell execution_count=28}\n``` {.python .cell-code}\ntimestamp = 2113441232.0\n\nprint(datetime.fromtimestamp(timestamp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2036-12-20 22:00:32\n```\n:::\n:::\n\n\n::: notes\nAnother common way to store datetimes is with Unix timestamps. These are just numbers counting seconds since January 1, 1970 — the \"start\" of time for most modern systems.\n\nTo convert a Unix timestamp to a datetime, use datetime.fromtimestamp(). This gives you a readable datetime.\n:::\n\n## Working with durations\n\n::: {#ec138b46 .cell execution_count=29}\n``` {.python .cell-code}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0)\nend_datetime = datetime(2025, 8, 16, 17, 30, 0)\nduration = end_datetime - start_datetime\n```\n:::\n\n\n::: notes\nDatetime objects support arithmetic operations similar to dates. We can compare, add, or subtract time intervals from them. Since they include both dates and times, handling durations involves a bit more detail, but it’s straightforward once you understand the basics. Let’s dive in.\nTo understand durations better, imagine placing two datetime points on a timeline. These points mark the beginning and end of an event, like a car trip. Visualizing them helps clarify the elapsed time between these moments.\nIn Python, you can assign the starting and ending times to variables named start_datetime and end_datetime.” When you subtract “start” from “end,” you get a timedelta object, which measures the length of time that passed between the two.\n:::\n\n## Getting duration in seconds\n\n::: {#332586db .cell execution_count=30}\n``` {.python .cell-code}\nprint(duration.total_seconds())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n30600.0\n```\n:::\n:::\n\n\n::: notes\nBy calling the total_seconds() method on the timedelta, you find out exactly how many seconds passed. For example, if the timedelta shows 3720 seconds, that means the event lasted for 1 hour and 2 minutes.\n:::\n\n## Creating timedeltas manually\n\n::: {#d76dca97 .cell execution_count=31}\n``` {.python .cell-code}\nfrom datetime import timedelta\nd1 = timedelta(seconds = 5)\n```\n:::\n\n\n::: notes\nYou can also build a timedelta from scratch by importing it from the datetime module. Just specify the amount of time you want, like one second or three minutes. For instance, d1 could represent a duration of 5 seconds.\n:::\n\n## Adding timedeltas to datetimes\n\n::: {#ae1f0bd2 .cell execution_count=32}\n``` {.python .cell-code}\nprint(start_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 09:00:00\n```\n:::\n:::\n\n\n::: {#6c9632e7 .cell execution_count=33}\n``` {.python .cell-code}\nprint(start_datetime + d1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 09:00:05\n```\n:::\n:::\n\n\n::: notes\nIf you add d1 to a datetime variable, the result will be a new datetime that’s exactly that much later. So adding 5 seconds to “start” shifts the time forward by two seconds.\n:::\n\n## Making larger timedeltas\n\n::: {#842ae63e .cell execution_count=34}\n``` {.python .cell-code}\nfrom datetime import timedelta\nd2 = timedelta(days = 2, seconds = 5)\nprint(start_datetime + d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-18 09:00:05\n```\n:::\n:::\n\n\n::: notes\nYou can make timedeltas of any size—days, hours, or even weeks. For example, d2 might be a duration of two days and five seconds. Adding delta2 to “start” moves the datetime ahead by that full amount. Timedeltas range from tiny microseconds to millions of years.\n:::\n\n## Using negative timedeltas\n\n::: {#e31a8fbb .cell execution_count=35}\n``` {.python .cell-code}\nd3 = timedelta(days = -2)\nprint(start_datetime + d3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-14 09:00:00\n```\n:::\n:::\n\n\n::: notes\nTimedeltas can also represent negative durations. If delta3 equals minus two days, adding it to “start” actually moves the datetime two days into the past.\n:::\n\n## Subtracting timedeltas\n\n::: {#fb065608 .cell execution_count=36}\n``` {.python .cell-code}\nd4 = timedelta(weeks = 2)\nprint(start_datetime - d4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-02 09:00:00\n```\n:::\n:::\n\n\n::: notes\nSubtracting a positive timedelta has the same effect as adding a negative one. For example, subtracting a two-week timedelta from “start” shifts the datetime back by two weeks, matching the result of adding a negative timedelta of the same length.\n:::\n\n## Understanding UTC offsets\n\n:::{.white-text}\n-  Naive datetime objects lack time zone information, making global time comparison inaccurate\n\n-  Historically, towns set clocks by local solar noon, causing slight time differences between nearby towns\n\n-  Small local time differences were insignificant before rapid travel and communication\n\n-  Trains and telegraphs highlighted the need for consistent regional timekeeping\n\n-  Governments standardized time zones across broad regions to unify clocks\n\n-  Example: New York follows Eastern Time within the U.S. time zone system\n\n-  Coordinated Universal Time (UTC) established in the UK as the global time reference\n\n-  Time zones are offsets from UTC: e.g., New York is UTC-4 (daylight savings), Tokyo is UTC+9\n:::\n\n::: notes\nSometimes you need to know the exact moment something happened. Until now, the datetime objects you've used are \"naive\" — meaning they don’t include any information about their time zone. Because of this, you can't accurately compare times from different parts of the world.\nBefore time zones existed, each town set its clock so that noon was when the sun was highest overhead locally.\nSo if another town 80 miles away did the same, its noon would be slightly different — maybe by 10 or 15 minutes. Back then, this small difference wasn’t a big deal.\nBut once trains and telegraphs allowed people and messages to move quickly over long distances, these small time differences caused confusion. People needed a consistent way to tell time across regions.\nTo fix this, governments agreed that all clocks within a broad area would follow the same time, even if that didn’t perfectly match the sun’s position. For example, the United States has several main time zones. The data we’ll use was recorded in New York, which follows Eastern Time.\nSince time no longer depends on the sun directly, how do we set our clocks? The answer lies with the United Kingdom, which created the first standard time reference called UTC (Coordinated Universal Time). Clocks worldwide are set based on UTC. Clocks west of the UK are behind UTC, and those east are ahead. For instance, New York is UTC-4 during daylight savings, while Tokyo is UTC+9.\n:::\n\n## Adding timezone info in code\n\n::: {#41afcc9d .cell execution_count=37}\n``` {.python .cell-code}\nfrom datetime import datetime, timedelta, timezone\n\nny_timezone = timezone(timedelta(hours=-4))\n\n# Timezon aware\ncar_ride_start = datetime(2025, 8, 16, 15, 0, 0, tzinfo=ny_timezone)\n\nprint(car_ride_start)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 15:00:00-04:00\n```\n:::\n:::\n\n\n::: notes\nLet’s jump into Python. We’ll import datetime, timedelta, and timezone. The timezone module lets us specify the time zone of our datetime objects, so they become \"aware\" of their offset from UTC.\nSuppose our car ride started at 3:00 PM in New York, which is UTC-4. We create a timezone object for UTC-4, then attach it to our datetime. When printed, this datetime now shows the UTC offset.\n:::\n\n## Converting between time zones\n\n::: {#f8bf076f .cell execution_count=38}\n``` {.python .cell-code}\ntokyo_timezone = timezone(timedelta(hours=9))  # Tokyo (UTC+9)\n\n# Convert New York time to Tokyo time using astimezone()\ncar_ride_tokyo_time = car_ride_start.astimezone(tokyo_timezone)\nprint(\"Same moment in Tokyo time:\", car_ride_tokyo_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSame moment in Tokyo time: 2025-08-17 04:00:00+09:00\n```\n:::\n:::\n\n\n::: notes\nBeing timezone-aware means we can convert times easily. For example, to see what the car ride time would be in Tokyo (UTC+9), we create a Tokyo timezone object and use the astimezone() method. The time adjusts to show the same moment, but according to Tokyo’s clock.\n:::\n\n## Adjust timezone vs changing tzinfo\n\n::: {#5be2faad .cell execution_count=39}\n``` {.python .cell-code}\nprint(start_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 09:00:00\n```\n:::\n:::\n\n\n::: {#2951aaa2 .cell execution_count=40}\n``` {.python .cell-code}\nprint(start_datetime.replace(tzinfo = timezone.utc))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 09:00:00+00:00\n```\n:::\n:::\n\n\n::: {#5ca4359b .cell execution_count=41}\n``` {.python .cell-code}\nprint(start_datetime.astimezone(timezone.utc))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 13:00:00+00:00\n```\n:::\n:::\n\n\n::: notes\nFinally, there’s a key difference between changing the timezone with astimezone() and just swapping the timezone info directly with replace(). Using replace() only swaps the timezone label without adjusting the clock time. But astimezone() changes both the time and the offset so the moment stays correct globally.\n:::\n\n## Time zone basics\n\n::: {#1ac7f3bc .cell execution_count=42}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dateutil import tz\n```\n:::\n\n\n::: notes\nNow that you know how UTC offsets work, let's move on to using time zones in real situations.\nThere’s a database called tz that's updated several times a year whenever time zone rules change. Many programming languages use this database. Because time zones change often, it’s better not to hard-code them into software like Python. Instead, we use a package called dateutil that taps into this database.\n:::\n\n## Creating a timezone object\n\n::: {#57840449 .cell execution_count=43}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\n```\n:::\n\n\n::: notes\nLet's create a timezone object for the Pacific time zone in the United States. The tz database organizes time zones by continent, then by a major city. For example, 'America/Los_Angeles' is used for the U.S. west coast. We get this timezone by calling tz.gettz() with 'America/Los_Angeles'.\n:::\n\n## More examples of time zones\n\n::: {#b412422d .cell execution_count=44}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\ntk = tz.gettz('Asia/Tokyo')\npa = tz.gettz('Europe/Paris')\n```\n:::\n\n\n::: notes\nHere are a few others you might use: 'Asia/Tokyo', and 'Europe/Paris'\n:::\n\n## Applying time zones to data\n\n::: {#1f958419 .cell execution_count=45}\n``` {.python .cell-code}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0, tzinfo = la)\nprint(start_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 09:00:00-07:00\n```\n:::\n:::\n\n\n::: {#829383bc .cell execution_count=46}\n``` {.python .cell-code}\nend_datetime = datetime(2025, 8, 16, 17, 30, 0, tzinfo = la)\nprint(end_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2025-08-16 17:30:00-07:00\n```\n:::\n:::\n\n\n::: notes\nLet's look at start_datetime again. Instead of manually adding the UTC offset, you apply the timezone object from tz. When you check the result, you’ll see it automatically includes the correct UTC offset.\nThe best part is that this timezone object updates the UTC offset depending on the date and time. For example, if you create a datetime for a ride in winter versus summer with the same timezone, the offset changes accordingly. We’ll cover daylight saving time soon, but basically, clocks shift twice a year in some regions. Instead of manually tracking these changes, tz handles it for you. It even knows historical changes going back decades. If you have data across many years, using tz helps keep all your timestamps consistent.\n:::\n\n## Starting daylight saving time\n\n::: notes\nSome regions adjust their clocks twice each year to enjoy longer evenings in summer. This adjustment is known as daylight saving time, though a better name might be daylight shifting. In some countries, it’s called “summer time.” Managing daylight saving time often complicates working with dates and times. To keep things simple, we'll first focus on when clocks move forward in spring. Later, we’ll cover what happens when clocks fall back in autumn.\n:::\n\n## Example of daylight saving time starting\n\n::: notes\nFor instance, on April 5, 2023, in New York City, the clock jumped from 1:59 am directly to 3:00 am. This means the clock “sprang forward,” skipping the entire 2 am hour. That hour never officially happened in New York on that day.\n:::\n\n## Changes in utc offset during daylight saving start\n\n::: notes\nTo compare New York’s time with other locations, we use a UTC offset. Before the shift, at 1 am on that day, New York was on Eastern Standard Time, which is UTC-5. After the jump, at 3 am, New York moved to Eastern Daylight Time, UTC-4. This means the offset changed by one hour forward.\n:::\n\n## Illustrating daylight saving time with code\n\n::: {#a98f3ad8 .cell execution_count=47}\n``` {.python .cell-code}\nfrom datetime import datetime\n\n# Before DST jump\ndt1 = datetime(2023, 3, 12, 1, 59, 59)\n\n# This time jumps forward to 3:00 AM (2:00 AM skipped)\ndt2 = datetime(2023, 3, 12, 3, 0, 0)\n\nprint(\"dt1:\", dt1.isoformat())\nprint(\"dt2:\", dt2.isoformat())\n\n# Calculate the difference\ndiff = dt2 - dt1\nprint(\"Difference:\", diff)\nprint(\"Difference:\", diff.total_seconds())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndt1: 2023-03-12T01:59:59\ndt2: 2023-03-12T03:00:00\nDifference: 1:00:01\nDifference: 3601.0\n```\n:::\n:::\n\n\n::: notes\nLet’s demonstrate this in code. We create two datetime objects for April 5, 2023: one at 2:59:59 am without timezone info, and another at 3:00 am, also without timezone info. Printing their ISO format confirms the times. Subtracting them shows a difference of one hour and one second, matching the clock change.\n:::\n\n## Defining timezone offsets manually\n\n::: {#05ca7f8f .cell execution_count=48}\n``` {.python .cell-code}\nfrom datetime import datetime, timezone, timedelta\n\n# Define timezones manually\nEST = timezone(timedelta(hours=-5))  # Eastern Standard Time (UTC-5)\nEDT = timezone(timedelta(hours=-4))  # Eastern Daylight Time (UTC-4)\n\n# Create datetime objects with these timezones\ndt_est = dt1.replace(tzinfo=EST)\ndt_edt = dt2.replace(tzinfo=EDT)\n\nprint(\"dt_est:\", dt_est.isoformat())\nprint(\"dt_edt:\", dt_edt.isoformat())\n\n# Calculate the difference\ndiff = dt_edt - dt_est\nprint(\"Difference:\", diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndt_est: 2023-03-12T01:59:59-05:00\ndt_edt: 2023-03-12T03:00:00-04:00\nDifference: 0:00:01\n```\n:::\n:::\n\n\n::: notes\nTo handle timezone-aware datetime objects, we first define the timezones manually. We create an Eastern Standard Time object with a UTC offset of -5 hours and an Eastern Daylight Time object with a UTC offset of -4 hours.\nWe assign the 1:59 am timestamp to EST and check the ISO format to confirm the offset. Then, we assign the 3:00 am timestamp to EDT and verify its offset too. When subtracting these timezone-aware datetime objects, the difference correctly shows only one second, since the hour was skipped. Using UTC offsets helps us compare times accurately.\n:::\n\n## Automating timezone rules with dateutil\n\n::: {#45a4203d .cell execution_count=49}\n``` {.python .cell-code}\nfrom dateutil import tz\n\n# Get the timezone object for America/New_York\nny_tz = tz.gettz(\"America/New_York\")\n\n# Create timezone-aware datetime for 1:59 AM on April 5, 2023\ndt_before = datetime(2023, 4, 5, 1, 59, 0, tzinfo=ny_tz)\n\n# Create timezone-aware datetime for 3:00 AM on April 5, 2023\ndt_after = datetime(2023, 4, 5, 3, 0, 0, tzinfo=ny_tz)\n\nprint(\"Before DST change:\", dt_before, \"Offset:\", dt_before.utcoffset())\nprint(\"After DST change: \", dt_after, \"Offset:\", dt_after.utcoffset())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore DST change: 2023-04-05 01:59:00-04:00 Offset: -1 day, 20:00:00\nAfter DST change:  2023-04-05 03:00:00-04:00 Offset: -1 day, 20:00:00\n```\n:::\n:::\n\n\n::: notes\nBut how can we know the exact moment clocks change without searching every time? The dateutil library helps here. Instead of manually defining timezones, we create a timezone object using dateutil’s tz.gettz(), specifying \"America/New_York.\" We then create timezone-aware datetime objects for 1:59 am and 3:00 am on April 5, 2023. Dateutil automatically assigns the correct offsets, recognizing the daylight saving change.\n:::\n\n## Ending daylight saving time\n\n\n\n::: notes\nLast time, we looked at what happens when clocks \"spring forward\" for daylight saving. Now, let's explore what occurs when clocks \"fall back\" in autumn. We’ll also explain how to handle events that happen during this repeated hour so there’s no confusion.\n:::\n\n## The repeated hour in daylight saving end\n\n::: notes\nImagine it’s October 29th, 2024, in New York City. At 2 AM, the clock turns back one hour to 1 AM again. This means there are two separate 1 AM times in a row. We can picture this by folding the timeline to show the hour happening twice.\n:::\n\n## Mapping the repeated hour to UTC\n\n::: {#87109303 .cell execution_count=50}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dateutil import tz\n\n# Time zone for New York\nny_tz = tz.gettz(\"America/New_York\")\nutc_tz = tz.UTC\n\n# First 1:00 AM (before the fall back, during DST)\nfirst_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to DST\nfirst_1am_local = first_1am_local.replace(fold=0)\nfirst_1am_utc = first_1am_local.astimezone(utc_tz)\n\n# Second 1:00 AM (after the fall back, standard time)\nsecond_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to Standard Time\nsecond_1am_local = second_1am_local.replace(fold=1)\nsecond_1am_utc = second_1am_local.astimezone(utc_tz)\n\n# Print the results\nprint(\"First 1:00 AM NY (DST):       \", first_1am_local)\nprint(\"First 1:00 AM in UTC:         \", first_1am_utc)\nprint()\nprint(\"Second 1:00 AM NY (Standard): \", second_1am_local)\nprint(\"Second 1:00 AM in UTC:        \", second_1am_utc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst 1:00 AM NY (DST):        2024-11-03 01:00:00-04:00\nFirst 1:00 AM in UTC:          2024-11-03 05:00:00+00:00\n\nSecond 1:00 AM NY (Standard):  2024-11-03 01:00:00-05:00\nSecond 1:00 AM in UTC:         2024-11-03 06:00:00+00:00\n```\n:::\n:::\n\n\n::: notes\nTo understand this, we convert everything to UTC. The first 1 AM corresponds to 5 AM UTC, because New York is 4 hours behind UTC during daylight saving. At 1:59:59 AM local time, it’s 5:59:59 AM UTC. Then the clock resets back to 1 AM, but time keeps moving forward in UTC. Now New York is 5 hours behind UTC, so the second 1 AM equals 6 AM UTC.\n:::\n\n## Working with ambiguous times in Python\n\n::: {#4c3ca1d1 .cell execution_count=51}\n``` {.python .cell-code}\nfrom datetime import datetime\nfrom dateutil import tz\nfrom dateutil.tz import datetime_ambiguous\n\n# Timezone for example (Europe/London ends DST on Oct 29, 2023 at 2 AM)\ntz_london = tz.gettz(\"Europe/London\")\n\n# Create a datetime during the DST fall-back transition\nambiguous_time = datetime(2023, 10, 29, 1, 0, 0, tzinfo=tz_london)\n\n# Check if it's ambiguous\nis_ambiguous = datetime_ambiguous(ambiguous_time)\nprint(\"Is 1:00 AM on Oct 29 ambiguous in London?\", is_ambiguous)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIs 1:00 AM on Oct 29 ambiguous in London? True\n```\n:::\n:::\n\n\n::: notes\nLet’s create a timezone object for our data. We make a datetime for October 29th at 1 AM. We check if this time is ambiguous — meaning it could happen twice — and find that it is. Next, we make another datetime at the same date and time but mark it as the second 1 AM using a special \"fold\" function. This tells Python which 1 AM we mean.\n:::\n\n## What fold means and why UTC matters\n\n::: {#9b894951 .cell execution_count=52}\n``` {.python .cell-code}\n# First 1 AM (DST)\nfirst_1am = ambiguous_time.replace(fold=0)\nfirst_utc = first_1am.astimezone(tz.UTC)\n\n# Second 1 AM (Standard Time)\nsecond_1am = ambiguous_time.replace(fold=1)\nsecond_utc = second_1am.astimezone(tz.UTC)\n\n# Display both versions and their UTC equivalents\nprint(\"\\nFirst 1:00 AM (DST):       \", first_1am)\nprint(\"First 1:00 AM in UTC:      \", first_utc)\n\nprint(\"\\nSecond 1:00 AM (Standard): \", second_1am)\nprint(\"Second 1:00 AM in UTC:     \", second_utc)\n\n# Duration between the two in UTC\nduration = second_utc - first_utc\nprint(\"\\nTime difference in UTC:\", duration)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFirst 1:00 AM (DST):        2023-10-29 01:00:00+01:00\nFirst 1:00 AM in UTC:       2023-10-29 00:00:00+00:00\n\nSecond 1:00 AM (Standard):  2023-10-29 01:00:00+00:00\nSecond 1:00 AM in UTC:      2023-10-29 01:00:00+00:00\n\nTime difference in UTC: 1:00:00\n```\n:::\n:::\n\n\n::: notes\nThe \"fold\" flag by itself doesn’t change how Python calculates time differences. Python ignores it during arithmetic unless you specifically handle it. To avoid confusion, we convert times to UTC, which has no repeats. Doing this, Python correctly shows that the two 1 AM times are one hour apart. So, to accurately measure time over daylight saving changes, always do calculations in UTC.\nWe’ve seen how to handle clocks moving forward and backward, using both manual offsets and timezone-aware libraries. Python sometimes ignores daylight saving differences, which is fine in many cases. But if you need precise results, set timezone info properly and convert to UTC for comparisons and duration calculations.\n:::\n\n## Reading date and time data in Pandas\n\n::: {#388574be .cell execution_count=53}\n``` {.python .cell-code}\nimport pandas as pd\n\nscooter = pd.read_csv(\"data/scooter_sharing_data.csv\")\nprint(scooter.head(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  trip_id scooter_id   user_id           start_time             end_time  \\\n0   T0001   SCOOT181  USER1114  2023-10-01 12:49:00  2023-10-01 13:41:00   \n1   T0002   SCOOT194  USER1104  2023-10-07 10:55:00  2023-10-07 11:05:00   \n2   T0003   SCOOT111  USER1223  2023-10-03 21:31:00  2023-10-03 22:08:00   \n\n  start_location end_location  distance_km  \n0         Zone 3       Zone 2         1.50  \n1         Zone 5       Zone 4         0.64  \n2         Zone 5       Zone 1         3.03  \n```\n:::\n:::\n\n\n::: notes\nIn this section, we'll explore how to handle date and time data using the Pandas library. If you've worked with Pandas before, this will build on that by introducing datetime data types.\nLet's begin by importing Pandas as pd. We'll load a CSV file named \"scooter_sharing_data.csv\" using pd.read_csv(). The data is saved into a variable called scooter. To get a quick look, we'll print out the first three rows.\nYou'll notice the index starts at zero on the far left. The table is wide, so it might wrap lines. Each row contains fields like start time, end time, start location, end location, bike ID, and the user type — whether they are a subscriber or a casual rider.\n:::\n\n## Selecting columns and rows in Pandas\n\n::: {#6625db63 .cell execution_count=54}\n``` {.python .cell-code}\nscooter['start_time']\n```\n\n::: {.cell-output .cell-output-display execution_count=441}\n```\n0     2023-10-01 12:49:00\n1     2023-10-07 10:55:00\n2     2023-10-03 21:31:00\n3     2023-10-07 10:48:00\n4     2023-10-03 01:35:00\n             ...         \n95    2023-10-05 16:11:00\n96    2023-10-07 07:51:00\n97    2023-10-06 03:02:00\n98    2023-10-03 15:47:00\n99    2023-10-06 01:06:00\nName: start_time, Length: 100, dtype: object\n```\n:::\n:::\n\n\n::: {#8c75831d .cell execution_count=55}\n``` {.python .cell-code}\nscooter.iloc[3]\n```\n\n::: {.cell-output .cell-output-display execution_count=442}\n```\ntrip_id                         T0004\nscooter_id                   SCOOT191\nuser_id                      USER1665\nstart_time        2023-10-07 10:48:00\nend_time          2023-10-07 11:19:00\nstart_location                 Zone 2\nend_location                   Zone 4\ndistance_km                      3.15\nName: 3, dtype: object\n```\n:::\n:::\n\n\n::: notes\nTo pick a specific column, like \"start time,\" we use brackets: bike_data['start_time']. For a single row, we use .iloc[], for example .iloc[3] for the third row. Currently, these start and end time columns are stored as plain text, not as real datetime objects, which limits what we can do with them.\n:::\n\n## Loading dates properly with `parse_dates`\n\n::: {#4ddef16f .cell execution_count=56}\n``` {.python .cell-code}\nscooter = pd.read_csv(\n  \"data/scooter_sharing_data.csv\",\n  parse_dates=[\"start_time\", \"end_time\"]\n)\n\nprint(scooter.head(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  trip_id scooter_id   user_id          start_time            end_time  \\\n0   T0001   SCOOT181  USER1114 2023-10-01 12:49:00 2023-10-01 13:41:00   \n1   T0002   SCOOT194  USER1104 2023-10-07 10:55:00 2023-10-07 11:05:00   \n2   T0003   SCOOT111  USER1223 2023-10-03 21:31:00 2023-10-03 22:08:00   \n\n  start_location end_location  distance_km  \n0         Zone 3       Zone 2         1.50  \n1         Zone 5       Zone 4         0.64  \n2         Zone 5       Zone 1         3.03  \n```\n:::\n:::\n\n\n::: {#70f201f0 .cell execution_count=57}\n``` {.python .cell-code}\n# If parsing fails or columns weren’t parsed correctly, convert manually\n# Example: converting 'start_time' manually\nscooter[\"start_time\"] = pd.to_datetime(scooter[\"start_time\"], format=\"%Y-%m-%d %H:%M:%S\")\n```\n:::\n\n\n::: notes\nWe can instruct Pandas to parse certain columns as datetime during loading by adding the parse_dates argument to read_csv(). We pass a list of column names we want converted. This way, Pandas automatically detects and converts them into datetime objects. If that fails, we can use pd.to_datetime() and specify the format manually.\n:::\n\n## Checking the datetime conversion\n\n::: {#fdb57533 .cell execution_count=58}\n``` {.python .cell-code}\n# Check the data types of columns\nprint(scooter.dtypes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntrip_id                   object\nscooter_id                object\nuser_id                   object\nstart_time        datetime64[ns]\nend_time          datetime64[ns]\nstart_location            object\nend_location              object\ndistance_km              float64\ndtype: object\n```\n:::\n:::\n\n\n::: {#edfb70cd .cell execution_count=59}\n``` {.python .cell-code}\n# Access the 'start_time' column for the first row\nprint(scooter.loc[0, \"start_time\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2023-10-01 12:49:00\n```\n:::\n:::\n\n\n::: {#2b7a16ef .cell execution_count=60}\n``` {.python .cell-code}\n# Verify its type\nprint(type(scooter.loc[0, \"start_time\"]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas._libs.tslibs.timestamps.Timestamp'>\n```\n:::\n:::\n\n\n::: notes\nAfter loading with parse_dates, accessing the \"start_time\" for a row returns a Pandas Timestamp. This object behaves much like a Python datetime, letting us manipulate and analyze dates easily.\n:::\n\n## Calculating duration using datetime arithmetic\n\n::: {#7ad33c8e .cell execution_count=61}\n``` {.python .cell-code}\nscooter[\"duration\"] = scooter[\"end_time\"] - scooter[\"start_time\"]\nprint(scooter.head(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  trip_id scooter_id   user_id          start_time            end_time  \\\n0   T0001   SCOOT181  USER1114 2023-10-01 12:49:00 2023-10-01 13:41:00   \n1   T0002   SCOOT194  USER1104 2023-10-07 10:55:00 2023-10-07 11:05:00   \n2   T0003   SCOOT111  USER1223 2023-10-03 21:31:00 2023-10-03 22:08:00   \n3   T0004   SCOOT191  USER1665 2023-10-07 10:48:00 2023-10-07 11:19:00   \n4   T0005   SCOOT100  USER1777 2023-10-03 01:35:00 2023-10-03 02:24:00   \n\n  start_location end_location  distance_km        duration  \n0         Zone 3       Zone 2         1.50 0 days 00:52:00  \n1         Zone 5       Zone 4         0.64 0 days 00:10:00  \n2         Zone 5       Zone 1         3.03 0 days 00:37:00  \n3         Zone 2       Zone 4         3.15 0 days 00:31:00  \n4         Zone 4       Zone 3         1.75 0 days 00:49:00  \n```\n:::\n:::\n\n\n::: notes\nNow that start and end times are datetimes, we can subtract them to find the ride duration. For example, create a new column duration by subtracting start time from end time. The result is a timedelta object showing how long each ride lasted. Printing the first five rows shows durations like 4 minutes, 1 hour 30 minutes, and so forth.\n:::\n\n## Working with timedelta and method chaining\n\n::: {#adca158e .cell execution_count=62}\n``` {.python .cell-code}\nscooter[\"duration_secs\"] = scooter[\"duration\"].dt.total_seconds()\nprint(scooter.head(5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  trip_id scooter_id   user_id          start_time            end_time  \\\n0   T0001   SCOOT181  USER1114 2023-10-01 12:49:00 2023-10-01 13:41:00   \n1   T0002   SCOOT194  USER1104 2023-10-07 10:55:00 2023-10-07 11:05:00   \n2   T0003   SCOOT111  USER1223 2023-10-03 21:31:00 2023-10-03 22:08:00   \n3   T0004   SCOOT191  USER1665 2023-10-07 10:48:00 2023-10-07 11:19:00   \n4   T0005   SCOOT100  USER1777 2023-10-03 01:35:00 2023-10-03 02:24:00   \n\n  start_location end_location  distance_km        duration  duration_secs  \n0         Zone 3       Zone 2         1.50 0 days 00:52:00         3120.0  \n1         Zone 5       Zone 4         0.64 0 days 00:10:00          600.0  \n2         Zone 5       Zone 1         3.03 0 days 00:37:00         2220.0  \n3         Zone 2       Zone 4         3.15 0 days 00:31:00         1860.0  \n4         Zone 4       Zone 3         1.75 0 days 00:49:00         2940.0  \n```\n:::\n:::\n\n\n::: notes\nPandas supports chaining methods for cleaner code. For example, to convert durations into total seconds, use .dt.total_seconds(). Writing it in multiple lines with backslashes helps readability. Viewing these converted values shows ride lengths in seconds instead of timedeltas — such as 240 seconds, 5400 seconds, etc.\n:::\n\n## Summarizing data in Pandas\n\n::: {#0f8e3fd8 .cell execution_count=63}\n``` {.python .cell-code}\nprint(scooter[\"duration_secs\"].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1788.6\n```\n:::\n:::\n\n\n::: {#52328631 .cell execution_count=64}\n``` {.python .cell-code}\nprint(scooter[\"duration_secs\"].sum())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n178860.0\n```\n:::\n:::\n\n\n::: notes\nLet’s start with the basics of summarizing data in Pandas. For columns with numeric data, you can easily get averages with .mean(), medians with .median(), totals with .sum(), and more. For example, calling .mean() on the duration column will show the average ride length is about 1788 seconds. Using .sum() wil tell us the total ride lengths of all rides in the dataset.\n:::\n\n## Summarizing data in Pandas with Python integration\n\n::: {#a3711c97 .cell execution_count=65}\n``` {.python .cell-code}\nprint(scooter[\"duration_secs\"].sum()/365)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n490.027397260274\n```\n:::\n:::\n\n\n::: notes\nThe results from Pandas functions work smoothly with regular Python code. For instance, if you sum all ride lengths and then divide by the total number of days in a year, you could find out the average of daily ride times. These are some things that you can do with pandas. I have done a detailed video on how to use pandas. I have linked it in the description below.\n:::\n\n## Plotting trip duration by start hour\n\n::: {#ddfe206f .cell output-location='column' execution_count=66}\n``` {.python .cell-code}\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# Add trip duration in minutes\nscooter[\"duration_min\"] = scooter[\"duration_secs\"]/ 60\n# Extract start hour\nscooter[\"start_hour\"] = scooter[\"start_time\"].dt.hour\n\nsns.barplot(data=scooter, \n            x=\"start_hour\", \n            y=\"duration_min\")\nplt.title(\"Trip Duration by Hour of Day\")\nplt.xlabel(\"Start Hour\")\nplt.ylabel(\"Duration (minutes)\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](date_time_python_files/figure-revealjs/cell-67-output-1.png){width=949 height=468}\n:::\n:::\n\n\n::: notes\nNow lets generate some plots. We will be using seaborn to make our plots. This plot shows how trip durations vary depending on the time of day. We can see whether users tend to take longer or shorter trips during certain hours. For example, longer trips occur during midday when users have more time, while shorter trips are more common during commute hours.\n:::\n\n## Trip Distance by Day of Week\n\n::: {#eb56bcf4 .cell output-location='column' execution_count=67}\n``` {.python .cell-code}\n# Extract day of week\nscooter[\"day_of_week\"] = scooter[\"start_time\"].\\\n                         dt.day_name()\n\n# Plot\nsns.boxplot(data=scooter, x=\"day_of_week\", \n            y=\"distance_km\", palette=\"Set2\")\nplt.title(\"Trip Distance by Day of the Week\")\nplt.xlabel(\"Day of Week\")\nplt.ylabel(\"Distance (km)\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](date_time_python_files/figure-revealjs/cell-68-output-1.png){width=949 height=468}\n:::\n:::\n\n\n::: notes\nHere is a boxplot where we’re looking at how far users travel on different days. The boxplot shows the distribution of trip distances, with the median and variation. This helps us see patterns—like travel distance on sundays were longer on average compared to other days. I have done detailed tutorials on plotting libraries matplotlib and seaborn on this channel. I have linked them in the video description.\n:::\n\n# Thank you\n\n::: notes\nWith that we have come to an end of today's video on date time analysis in python. Please make sure to hit like and subscribe. Also check out my other videos on pandas, matplotlib and seaborn. Thank you.\n:::\n\n",
    "supporting": [
      "date_time_python_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}