{"title":"Handling date time in pythonn","markdown":{"yaml":{"title":"Handling date time in pythonn","format":{"revealjs":{"height":1080,"width":1920,"slide-number":true,"theme":"theme/dsfe_theme.scss","code-copy":false,"logo":"logo/dsfe_logo.svg","footer":"Data Science For Everyone"}},"jupyter":"python3","highlight-style":"dracula","brand":"brand/_dsfe_brand.yml","execute":{"echo":true}},"headingText":"Date in python","containsRefs":false,"markdown":"\n\n\n::: notes\nWelcome to data science for everyone. Today I’ll be guiding you through this course on handling dates and times in Python. Dates are everywhere in data science—whether it's tracking stock market changes, running experiments, recording birthdays, or analyzing political events. All of these happen at specific points in time. Being able to work with time-based data is a fundamental skill for any data scientist.\n\nPython includes a special class for working with dates, called date. It’s similar to other data types like strings, numbers, or arrays—it has its own rules for how to create it and methods for using it. In this lesson, we’ll focus on how to create date objects and how to pull basic information from them.\n:::\n\n## Date in python\n\n```{python}\ndates = [\"12/03/2025\", \"11/05/2025\"]\n```\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nSo, why do we need a separate class just for dates? Let’s find out. In this chapter, you’ll work with 67 years of hurricane landfall data in Florida. You’ll start with a list called two_hurricanes, which includes the dates of two hurricanes stored as strings—one from October 7th, 2016, and another from June 21st, 2017. These dates follow the U.S. format: month, day, year.\n\nNow imagine trying to answer a few questions:\n\nHow many days passed between these two hurricanes?\n\nAre they listed in the correct chronological order?\n\nWhat day of the week did each one happen?\n\nDoing this manually would be tedious. But with Python, it’s simple. By the end of this chapter, you’ll know exactly how to do all of these things.\n:::\n\n## Creating date objects\n\n```{python}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\n```\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nTo start working with dates, we first need to import the date class. All date and time-related classes live inside Python’s datetime module. We create a date using the date() function.\n\nHere’s how we turn our two hurricane dates into Python date objects. The date() function takes three arguments: year, month, and day—in that order. So for October 7, 2016, we write date(2016, 10, 7), and for June 21, 2017, we write date(2017, 6, 21). It’s a simple format: from largest to smallest—year, then month, then day.\n\nLater on, we’ll see how to convert strings into dates, but for now, we’ll stick to creating them manually or using pre-made lists.\n:::\n\n## Accessing date components\n\n```{python}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\nprint(dates[0].year)\nprint(dates[0].month)\nprint(dates[0].day)\n```\n\n::: notes\nOnce you have a date object, you can easily get its individual parts. Want the year? Just use .year. Need the month or day? Use .month and .day. It’s straightforward and easy to remember.\n:::\n\n## Finding the weekday\n\n```{python}\nprint(dates[0].weekday())\n```\n\n::: white-text\n0 = Monday 1 = Tuesday ... 6 = Sunday What are the days of the week?\n:::\n\n::: notes\nPython can also help with more complex tasks. For example, to find out what day of the week a date falls on, you can use the .weekday() method. This method returns a number from 0 to 6, where 0 is Monday, 1 is Tuesday, and so on—up to 6, which is Sunday. So if .weekday() returns 4, that means the date is a Friday.\n:::\n\n## Understanding date math\n\n```{python}\na = 21\nb = 24\nlist = [a, b]\nprint(max(list))\nprint(a - b)\nprint(a + 10)\n```\n\n::: notes\nToday, we’re going to explore how to do math with dates. That means things like figuring out how many days are between two dates, moving a date forward or backward, and comparing which date comes first. Let’s go back to something familiar: simple math with numbers. If we pick two numbers—say 21 and 24—we can use Python to figure out which one is smaller. We’ll store them as variables and place them into a list. Then, using the max() function, Python will return the smallest one. In our case, that’s 21. We can perform mathematical operations on the numbers as well.\n:::\n\n## Turning numbers into dates\n\n```{python}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\ndate2 = date(2025, 5, 11)\ndate_list = [date1, date2]\nprint(max(date_list))\n```\n\n::: notes\nNow let’s switch from numbers to dates. We’ll use the date class from Python’s datetime module. We create two date objects: one for each of these dates. We can then put these into a list and use the max() function again. This time, it tells us which date comes first.\n:::\n\n## Subtracting dates\n\n```{python}\ndate_sub = date2 - date1\ndate_sub.days\n```\n\n```{python}\ntype(date_sub)\n```\n\n::: notes\nJust like numbers, we can subtract one date from another. If we subtract March 10th from April 8th, Python gives us something called a timedelta object. This object tells us the difference between the two dates. If we check its .days attribute, we’ll see how many days are in between—in this case, 29.\n:::\n\n## Adding time to dates\n\n```{python}\nfrom datetime import timedelta\ntd = timedelta(days = 10)\nprint(date1 + td)\n```\n\n::: notes\nWe can also go the other way: we can add days to a date. To do that, we import timedelta, then create a 29-day time span. If we add that to March 10th, Python gives us April 8th. It takes care of counting the days in each month automatically—no need to remember how many days are in March!\n:::\n\n## The ISO 8601 format\n\n```{python}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\nprint(date1) # ISO format (YYYY-MM-DD)\n```\n\n```{python}\nprint([date1.isoformat()])\n```\n\n::: notes\nPython makes it easy to turn date objects into strings that are easier to read or use. This is helpful when you want to display a date on the screen, include it in a file name, or save it in a CSV or Excel file. Let’s start with how Python shows a date by default. We'll import date from datetime and create a date for July 15, 2022. When we print this date, Python shows it like this: 2022-07-15. That’s year first, then month, then day — all separated by dashes. This format is known as ISO 8601. It's standardized, and always uses two digits for the month and day, even if they're below 10. If we want to get this date as a string — say, to save in a CSV file — we can use the .isoformat() method.\n:::\n\n## Why ISO 8601 is useful\n\n```{python}\ndates_list = [\"2001-09-25\", \"2003-02-10\"]\nprint(sorted(dates_list))\n```\n\n::: notes\nOne big advantage of ISO 8601 is that it sorts dates properly when they’re in string format. Let’s say we have two dates as strings: “2003-02-10” and “2001-09-25”. If we put them in a list and sort it, they’ll be ordered from oldest to newest. That’s because ISO 8601 format puts the biggest unit (year) first, followed by month and day. This makes it really useful for naming files in a way that keeps them in chronological order.\n:::\n\n## Other date formats\n\n```{python}\n#| eval: false\nd.strftime()\n```\n\n::: notes\nIf you don’t want to use the ISO format, Python gives you other options. You can use the strftime() method to format dates however you want.\n:::\n\n## Using `strftime` to format dates\n\n```{python}\ndate3 = date(2021, 4, 3)\nprint(date3.strftime(\"%Y\"))\nprint(date3.strftime(\"%m\"))\nprint(date3.strftime(\"The month is %m.\"))\nprint(date3.strftime(\"%m/%d/%Y\"))\nprint(date3.strftime(\"%Y-%j\")) # format 'YYYY-DDD'\nprint(date3.strftime(\"%B (%Y)\")) # format 'MONTH (YYYY)'\n```\n\n::: notes\nThe strftime() method lets you create a string version of a date using a format code. Let’s create a date for April 3, 2021. If we use strftime(\"%Y\"), Python gives us just the year: “2021”. You can include this in a longer string too — for example, \"Year: %Y\" would return \"Year: 2021\". There are more format codes too. %m gives you the month as a number, and %d gives you the day. So \"%m/%d/%Y\" would return something like \"04/03/2021\". You can combine these in any way you like to match the format you need.\n:::\n\n## Combining dates and times\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14)\n```\n\n::: notes\nSo far, we've only been working with dates. Now, it's time to bring in the concept of time — not just the day, but the hour, minute, and second within that day.\nLet’s look at an example: imagine something happened on March 14, 2022, at 3:45:10 PM. Instead of just storing the date, we want to include the exact time. Let’s see how we can represent this in Python.\nTo work with both dates and times, we need to import the datetime class from the datetime module. Yes, both are called “datetime.” It’s a bit confusing at first, but you’ll get used to it quickly.\nLet’s make a new datetime object and store it in a variable called dt. We’ll give it all the information it needs right when we create it.\nThe first three values we pass in are the same as when we create a date object — the year, followed by the month, then the day. All as numbers.\n:::\n\n## Adding the hour\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\n```\n\n::: notes\nAfter the day, we add the hour. Python uses 24-hour time by default, so 3 PM would be 15.\nNext, we enter the minutes — in this case, 45. Remember, there are 60 minutes in an hour.\nFinally, we include the seconds. So, for 10 seconds past the minute, we add 10 as the last argument. Our full datetime now includes all six parts: year, month, day, hour, minute, and second.\n:::\n\n## Including microseconds\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10, 250000)\n\n# explicit named arguments\ndt = datetime(year = 2022, month = 3, day = 14, \n              hour = 15, minute = 45, second = 10, \n              microsecond = 250000)\n```\n\n::: notes\nIf you need more precision, you can add microseconds. For example, adding 250,000 microseconds means the time is 0.25 seconds past 9:45:10. Python can track time down to millionths of a second — and if you need even more precision, like nanoseconds, we’ll cover that when we get to Pandas.\nThat's a lot to remember, so if it helps, you can use named arguments like year=2022, month=3, and so on. This makes your code easier to read and reduces the chance of mistakes.\n:::\n\n## Modifying a datetime\n\n```{python}\nprint(dt)\n```\n\n```{python}\ndt_new = dt.replace(minute = 22, microsecond = 500000)\nprint(dt_new)\n```\n\n::: notes\nYou can also take an existing datetime and tweak it using the replace() method. For example, if you want to round a time down to the start of the hour, you can set minutes, seconds, and microseconds to zero. This gives you a new datetime, with the other values unchanged.\n:::\n\n## Example dataset: City scooter trips\n\n::: notes\nFor the rest of this course, we’ll use data from a scooter sharing service in Austin, Texas. Each record shows when a scooter was unlocked and when it was returned. We'll focus on one scooter, ID “X13456,” and track all its trips in the last three months of 2022. Each trip has a start and end datetime — perfect for practicing with date and time data.\n:::\n\n## Printing and parsing datetimes\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\nprint(dt.strftime(\"%Y-%m-%d\"))\n```\n\n```{python}\nprint(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n```\n\n```{python}\nprint(dt.strftime(\"%Y-%m-%d %I:%M:%S %p\"))\n```\n\n::: notes\nJust like dates, datetimes can be displayed in many different ways. Python can also take a string and turn it into a datetime. Let’s first look at how to format and print a datetime, then move on to how Python can read one from a string.\nWe’ll start by creating a datetime for March 14, 2022, at 3:45:10 PM. To turn this into a nicely formatted string, we’ll use strftime().\n\nFirst, we’ll print just the date using %Y for the full year, %m for the month, and %d for the day.\n\nNext, we’ll include the time using %H for hour (24-hour format), %M for minutes, and %S for seconds.\n\nYou can also use codes for 12-hour time and add AM or PM if needed. To convert your datetime to a 12-hour format with AM/PM, you can use the format codes %I for the hour (12-hour clock) and %p for AM/PM\n:::\n\n## ISO 8601 format\n\n```{python}\nprint(dt.isoformat())\n```\n\n::: notes\nPython also has a built-in way to print a datetime in a standard format using isoformat().\n\nThis outputs the date and time as YYYY-MM-DDTHH:MM:SS, which is a widely accepted format and great to use when you’re unsure what format to pick.\n:::\n\n## Parsing datetimes with strptime\n\n```{python}\nfrom datetime import datetime\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m/%d/%Y %H:%M:%S\")\n```\n\n::: notes\nNow let’s turn a string into a datetime. This is useful when you get dates from text files, websites, or APIs.\n\nTo start, import the datetime class from the datetime module.\nThe function we’ll use is called strptime(), which means “string parse time.”\n\nIt takes two arguments: the string that contains the date and time, and a format string that tells Python how to read it.\nLet’s say we have a string like '10/12/2023 08:45:27'. That’s October 12, 2023 at 8:45:27 in the morning.\nNow we give Python the format it needs to understand the string.\n\nIn this case, the format would be '%m/%d/%Y %H:%M:%S'. This tells Python to expect a month, day, and year with slashes, followed by time separated by colons.\n\nUsually, once per dataset, you’ll figure out this format and reuse it.\n:::\n\n## Confirming the result\n\n```{python}\nprint(type(dt2))\n```\n\n```{python}\nprint(dt2)\n```\n\n::: notes\nIf we check the type of the result, it’s a datetime object.\n\nAnd if we print it, Python shows a clean version of the datetime — proving it was parsed correctly.\n:::\n\n## When formats don’t match\n\n```{python}\n#| error: true\nfrom datetime import datetime\n\n# Incorrect formatting\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m-%d-%Y %H:%M:%S\")\n```\n\n::: notes\nThe format must exactly match the string.\n\nIf you forget to include the time, or if there’s an extra comma or symbol in the string, Python will throw an error. Always check that your format and string align.\n:::\n\n## Working with Unix timestamps\n\n```{python}\ntimestamp = 2113441232.0\n\nprint(datetime.fromtimestamp(timestamp))\n```\n\n::: notes\nAnother common way to store datetimes is with Unix timestamps. These are just numbers counting seconds since January 1, 1970 — the \"start\" of time for most modern systems.\n\nTo convert a Unix timestamp to a datetime, use datetime.fromtimestamp(). This gives you a readable datetime.\n:::\n\n## Working with durations\n\n```{python}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0)\nend_datetime = datetime(2025, 8, 16, 17, 30, 0)\nduration = end_datetime - start_datetime\n```\n\n::: notes\nDatetime objects support arithmetic operations similar to dates. We can compare, add, or subtract time intervals from them. Since they include both dates and times, handling durations involves a bit more detail, but it’s straightforward once you understand the basics. Let’s dive in.\nTo understand durations better, imagine placing two datetime points on a timeline. These points mark the beginning and end of an event, like a car trip. Visualizing them helps clarify the elapsed time between these moments.\nIn Python, you can assign the starting and ending times to variables named start_datetime and end_datetime.” When you subtract “start” from “end,” you get a timedelta object, which measures the length of time that passed between the two.\n:::\n\n## Getting duration in seconds\n\n```{python}\nprint(duration.total_seconds())\n```\n\n::: notes\nBy calling the total_seconds() method on the timedelta, you find out exactly how many seconds passed. For example, if the timedelta shows 3720 seconds, that means the event lasted for 1 hour and 2 minutes.\n:::\n\n## Creating timedeltas manually\n\n```{python}\nfrom datetime import timedelta\nd1 = timedelta(seconds = 5)\n```\n\n::: notes\nYou can also build a timedelta from scratch by importing it from the datetime module. Just specify the amount of time you want, like one second or three minutes. For instance, d1 could represent a duration of 5 seconds.\n:::\n\n## Adding timedeltas to datetimes\n\n```{python}\nprint(start_datetime)\n```\n\n```{python}\nprint(start_datetime + d1)\n```\n\n::: notes\nIf you add d1 to a datetime variable, the result will be a new datetime that’s exactly that much later. So adding 5 seconds to “start” shifts the time forward by two seconds.\n:::\n\n## Making larger timedeltas\n\n```{python}\nfrom datetime import timedelta\nd2 = timedelta(days = 2, seconds = 5)\nprint(start_datetime + d2)\n```\n\n::: notes\nYou can make timedeltas of any size—days, hours, or even weeks. For example, d2 might be a duration of two days and five seconds. Adding delta2 to “start” moves the datetime ahead by that full amount. Timedeltas range from tiny microseconds to millions of years.\n:::\n\n## Using negative timedeltas\n\n```{python}\nd3 = timedelta(days = -2)\nprint(start_datetime + d3)\n```\n\n::: notes\nTimedeltas can also represent negative durations. If delta3 equals minus two days, adding it to “start” actually moves the datetime two days into the past.\n:::\n\n## Subtracting timedeltas\n\n```{python}\nd4 = timedelta(weeks = 2)\nprint(start_datetime - d4)\n```\n\n::: notes\nSubtracting a positive timedelta has the same effect as adding a negative one. For example, subtracting a two-week timedelta from “start” shifts the datetime back by two weeks, matching the result of adding a negative timedelta of the same length.\n:::\n\n## Understanding UTC offsets\n\n:::{.white-text}\n-  Naive datetime objects lack time zone information, making global time comparison inaccurate\n\n-  Historically, towns set clocks by local solar noon, causing slight time differences between nearby towns\n\n-  Small local time differences were insignificant before rapid travel and communication\n\n-  Trains and telegraphs highlighted the need for consistent regional timekeeping\n\n-  Governments standardized time zones across broad regions to unify clocks\n\n-  Example: New York follows Eastern Time within the U.S. time zone system\n\n-  Coordinated Universal Time (UTC) established in the UK as the global time reference\n\n-  Time zones are offsets from UTC: e.g., New York is UTC-4 (daylight savings), Tokyo is UTC+9\n:::\n\n::: notes\nSometimes you need to know the exact moment something happened. Until now, the datetime objects you've used are \"naive\" — meaning they don’t include any information about their time zone. Because of this, you can't accurately compare times from different parts of the world.\nBefore time zones existed, each town set its clock so that noon was when the sun was highest overhead locally.\nSo if another town 80 miles away did the same, its noon would be slightly different — maybe by 10 or 15 minutes. Back then, this small difference wasn’t a big deal.\nBut once trains and telegraphs allowed people and messages to move quickly over long distances, these small time differences caused confusion. People needed a consistent way to tell time across regions.\nTo fix this, governments agreed that all clocks within a broad area would follow the same time, even if that didn’t perfectly match the sun’s position. For example, the United States has several main time zones. The data we’ll use was recorded in New York, which follows Eastern Time.\nSince time no longer depends on the sun directly, how do we set our clocks? The answer lies with the United Kingdom, which created the first standard time reference called UTC (Coordinated Universal Time). Clocks worldwide are set based on UTC. Clocks west of the UK are behind UTC, and those east are ahead. For instance, New York is UTC-4 during daylight savings, while Tokyo is UTC+9.\n:::\n\n## Adding timezone info in code\n\n```{python}\nfrom datetime import datetime, timedelta, timezone\n\nny_timezone = timezone(timedelta(hours=-4))\n\n# Timezon aware\ncar_ride_start = datetime(2025, 8, 16, 15, 0, 0, tzinfo=ny_timezone)\n\nprint(car_ride_start)\n```\n\n::: notes\nLet’s jump into Python. We’ll import datetime, timedelta, and timezone. The timezone module lets us specify the time zone of our datetime objects, so they become \"aware\" of their offset from UTC.\nSuppose our car ride started at 3:00 PM in New York, which is UTC-4. We create a timezone object for UTC-4, then attach it to our datetime. When printed, this datetime now shows the UTC offset.\n:::\n\n## Converting between time zones\n\n```{python}\ntokyo_timezone = timezone(timedelta(hours=9))  # Tokyo (UTC+9)\n\n# Convert New York time to Tokyo time using astimezone()\ncar_ride_tokyo_time = car_ride_start.astimezone(tokyo_timezone)\nprint(\"Same moment in Tokyo time:\", car_ride_tokyo_time)\n```\n\n::: notes\nBeing timezone-aware means we can convert times easily. For example, to see what the car ride time would be in Tokyo (UTC+9), we create a Tokyo timezone object and use the astimezone() method. The time adjusts to show the same moment, but according to Tokyo’s clock.\n:::\n\n## Adjust timezone vs changing tzinfo\n\n```{python}\nprint(start_datetime)\n```\n\n```{python}\nprint(start_datetime.replace(tzinfo = timezone.utc))\n```\n\n```{python}\nprint(start_datetime.astimezone(timezone.utc))\n```\n\n::: notes\nFinally, there’s a key difference between changing the timezone with astimezone() and just swapping the timezone info directly with replace(). Using replace() only swaps the timezone label without adjusting the clock time. But astimezone() changes both the time and the offset so the moment stays correct globally.\n:::\n\n## Time zone basics\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n```\n\n::: notes\nNow that you know how UTC offsets work, let's move on to using time zones in real situations.\nThere’s a database called tz that's updated several times a year whenever time zone rules change. Many programming languages use this database. Because time zones change often, it’s better not to hard-code them into software like Python. Instead, we use a package called dateutil that taps into this database.\n:::\n\n## Creating a timezone object\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\n```\n\n::: notes\nLet's create a timezone object for the Pacific time zone in the United States. The tz database organizes time zones by continent, then by a major city. For example, 'America/Los_Angeles' is used for the U.S. west coast. We get this timezone by calling tz.gettz() with 'America/Los_Angeles'.\n:::\n\n## More examples of time zones\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\ntk = tz.gettz('Asia/Tokyo')\npa = tz.gettz('Europe/Paris')\n```\n\n::: notes\nHere are a few others you might use: 'Asia/Tokyo', and 'Europe/Paris'\n:::\n\n## Applying time zones to data\n\n```{python}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0, tzinfo = la)\nprint(start_datetime)\n```\n\n```{python}\nend_datetime = datetime(2025, 8, 16, 17, 30, 0, tzinfo = la)\nprint(end_datetime)\n```\n\n::: notes\nLet's look at start_datetime again. Instead of manually adding the UTC offset, you apply the timezone object from tz. When you check the result, you’ll see it automatically includes the correct UTC offset.\nThe best part is that this timezone object updates the UTC offset depending on the date and time. For example, if you create a datetime for a ride in winter versus summer with the same timezone, the offset changes accordingly. We’ll cover daylight saving time soon, but basically, clocks shift twice a year in some regions. Instead of manually tracking these changes, tz handles it for you. It even knows historical changes going back decades. If you have data across many years, using tz helps keep all your timestamps consistent.\n:::\n\n## Starting daylight saving time\n\n::: notes\nSome regions adjust their clocks twice each year to enjoy longer evenings in summer. This adjustment is known as daylight saving time, though a better name might be daylight shifting. In some countries, it’s called “summer time.” Managing daylight saving time often complicates working with dates and times. To keep things simple, we'll first focus on when clocks move forward in spring. Later, we’ll cover what happens when clocks fall back in autumn.\n:::\n\n## Example of daylight saving time starting\n\n::: notes\nFor instance, on April 5, 2023, in New York City, the clock jumped from 1:59 am directly to 3:00 am. This means the clock “sprang forward,” skipping the entire 2 am hour. That hour never officially happened in New York on that day.\n:::\n\n## Changes in utc offset during daylight saving start\n\n::: notes\nTo compare New York’s time with other locations, we use a UTC offset. Before the shift, at 1 am on that day, New York was on Eastern Standard Time, which is UTC-5. After the jump, at 3 am, New York moved to Eastern Daylight Time, UTC-4. This means the offset changed by one hour forward.\n:::\n\n## Illustrating daylight saving time with code\n\n```{python}\nfrom datetime import datetime\n\n# Before DST jump\ndt1 = datetime(2023, 3, 12, 1, 59, 59)\n\n# This time jumps forward to 3:00 AM (2:00 AM skipped)\ndt2 = datetime(2023, 3, 12, 3, 0, 0)\n\nprint(\"dt1:\", dt1.isoformat())\nprint(\"dt2:\", dt2.isoformat())\n\n# Calculate the difference\ndiff = dt2 - dt1\nprint(\"Difference:\", diff)\nprint(\"Difference:\", diff.total_seconds())\n```\n\n::: notes\nLet’s demonstrate this in code. We create two datetime objects for April 5, 2023: one at 2:59:59 am without timezone info, and another at 3:00 am, also without timezone info. Printing their ISO format confirms the times. Subtracting them shows a difference of one hour and one second, matching the clock change.\n:::\n\n## Defining timezone offsets manually\n\n```{python}\nfrom datetime import datetime, timezone, timedelta\n\n# Define timezones manually\nEST = timezone(timedelta(hours=-5))  # Eastern Standard Time (UTC-5)\nEDT = timezone(timedelta(hours=-4))  # Eastern Daylight Time (UTC-4)\n\n# Create datetime objects with these timezones\ndt_est = dt1.replace(tzinfo=EST)\ndt_edt = dt2.replace(tzinfo=EDT)\n\nprint(\"dt_est:\", dt_est.isoformat())\nprint(\"dt_edt:\", dt_edt.isoformat())\n\n# Calculate the difference\ndiff = dt_edt - dt_est\nprint(\"Difference:\", diff)\n\n```\n\n::: notes\nTo handle timezone-aware datetime objects, we first define the timezones manually. We create an Eastern Standard Time object with a UTC offset of -5 hours and an Eastern Daylight Time object with a UTC offset of -4 hours.\nWe assign the 1:59 am timestamp to EST and check the ISO format to confirm the offset. Then, we assign the 3:00 am timestamp to EDT and verify its offset too. When subtracting these timezone-aware datetime objects, the difference correctly shows only one second, since the hour was skipped. Using UTC offsets helps us compare times accurately.\n:::\n\n## Automating timezone rules with dateutil\n\n```{python}\nfrom dateutil import tz\n\n# Get the timezone object for America/New_York\nny_tz = tz.gettz(\"America/New_York\")\n\n# Create timezone-aware datetime for 1:59 AM on April 5, 2023\ndt_before = datetime(2023, 4, 5, 1, 59, 0, tzinfo=ny_tz)\n\n# Create timezone-aware datetime for 3:00 AM on April 5, 2023\ndt_after = datetime(2023, 4, 5, 3, 0, 0, tzinfo=ny_tz)\n\nprint(\"Before DST change:\", dt_before, \"Offset:\", dt_before.utcoffset())\nprint(\"After DST change: \", dt_after, \"Offset:\", dt_after.utcoffset())\n\n```\n\n::: notes\nBut how can we know the exact moment clocks change without searching every time? The dateutil library helps here. Instead of manually defining timezones, we create a timezone object using dateutil’s tz.gettz(), specifying \"America/New_York.\" We then create timezone-aware datetime objects for 1:59 am and 3:00 am on April 5, 2023. Dateutil automatically assigns the correct offsets, recognizing the daylight saving change.\n:::\n\n## Ending daylight saving time\n\n\n\n::: notes\nLast time, we looked at what happens when clocks \"spring forward\" for daylight saving. Now, let's explore what occurs when clocks \"fall back\" in autumn. We’ll also explain how to handle events that happen during this repeated hour so there’s no confusion.\n:::\n\n## The repeated hour in daylight saving end\n\n::: notes\nImagine it’s October 29th, 2024, in New York City. At 2 AM, the clock turns back one hour to 1 AM again. This means there are two separate 1 AM times in a row. We can picture this by folding the timeline to show the hour happening twice.\n:::\n\n## Mapping the repeated hour to UTC\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\n# Time zone for New York\nny_tz = tz.gettz(\"America/New_York\")\nutc_tz = tz.UTC\n\n# First 1:00 AM (before the fall back, during DST)\nfirst_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to DST\nfirst_1am_local = first_1am_local.replace(fold=0)\nfirst_1am_utc = first_1am_local.astimezone(utc_tz)\n\n# Second 1:00 AM (after the fall back, standard time)\nsecond_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to Standard Time\nsecond_1am_local = second_1am_local.replace(fold=1)\nsecond_1am_utc = second_1am_local.astimezone(utc_tz)\n\n# Print the results\nprint(\"First 1:00 AM NY (DST):       \", first_1am_local)\nprint(\"First 1:00 AM in UTC:         \", first_1am_utc)\nprint()\nprint(\"Second 1:00 AM NY (Standard): \", second_1am_local)\nprint(\"Second 1:00 AM in UTC:        \", second_1am_utc)\n```\n\n::: notes\nTo understand this, we convert everything to UTC. The first 1 AM corresponds to 5 AM UTC, because New York is 4 hours behind UTC during daylight saving. At 1:59:59 AM local time, it’s 5:59:59 AM UTC. Then the clock resets back to 1 AM, but time keeps moving forward in UTC. Now New York is 5 hours behind UTC, so the second 1 AM equals 6 AM UTC.\n:::\n\n## Working with ambiguous times in Python\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\nfrom dateutil.tz import datetime_ambiguous\n\n# Timezone for example (Europe/London ends DST on Oct 29, 2023 at 2 AM)\ntz_london = tz.gettz(\"Europe/London\")\n\n# Create a datetime during the DST fall-back transition\nambiguous_time = datetime(2023, 10, 29, 1, 0, 0, tzinfo=tz_london)\n\n# Check if it's ambiguous\nis_ambiguous = datetime_ambiguous(ambiguous_time)\nprint(\"Is 1:00 AM on Oct 29 ambiguous in London?\", is_ambiguous)\n```\n\n::: notes\nLet’s create a timezone object for our data. We make a datetime for October 29th at 1 AM. We check if this time is ambiguous — meaning it could happen twice — and find that it is. Next, we make another datetime at the same date and time but mark it as the second 1 AM using a special \"fold\" function. This tells Python which 1 AM we mean.\n:::\n\n## What fold means and why UTC matters\n\n```{python}\n# First 1 AM (DST)\nfirst_1am = ambiguous_time.replace(fold=0)\nfirst_utc = first_1am.astimezone(tz.UTC)\n\n# Second 1 AM (Standard Time)\nsecond_1am = ambiguous_time.replace(fold=1)\nsecond_utc = second_1am.astimezone(tz.UTC)\n\n# Display both versions and their UTC equivalents\nprint(\"\\nFirst 1:00 AM (DST):       \", first_1am)\nprint(\"First 1:00 AM in UTC:      \", first_utc)\n\nprint(\"\\nSecond 1:00 AM (Standard): \", second_1am)\nprint(\"Second 1:00 AM in UTC:     \", second_utc)\n\n# Duration between the two in UTC\nduration = second_utc - first_utc\nprint(\"\\nTime difference in UTC:\", duration)\n```\n\n::: notes\nThe \"fold\" flag by itself doesn’t change how Python calculates time differences. Python ignores it during arithmetic unless you specifically handle it. To avoid confusion, we convert times to UTC, which has no repeats. Doing this, Python correctly shows that the two 1 AM times are one hour apart. So, to accurately measure time over daylight saving changes, always do calculations in UTC.\nWe’ve seen how to handle clocks moving forward and backward, using both manual offsets and timezone-aware libraries. Python sometimes ignores daylight saving differences, which is fine in many cases. But if you need precise results, set timezone info properly and convert to UTC for comparisons and duration calculations.\n:::\n\n## Reading date and time data in Pandas\n\n```{python}\nimport pandas as pd\n\nscooter = pd.read_csv(\"data/scooter_sharing_data.csv\")\nprint(scooter.head(3))\n```\n\n::: notes\nIn this section, we'll explore how to handle date and time data using the Pandas library. If you've worked with Pandas before, this will build on that by introducing datetime data types.\nLet's begin by importing Pandas as pd. We'll load a CSV file named \"scooter_sharing_data.csv\" using pd.read_csv(). The data is saved into a variable called scooter. To get a quick look, we'll print out the first three rows.\nYou'll notice the index starts at zero on the far left. The table is wide, so it might wrap lines. Each row contains fields like start time, end time, start location, end location, bike ID, and the user type — whether they are a subscriber or a casual rider.\n:::\n\n## Selecting columns and rows in Pandas\n\n```{python}\nscooter['start_time']\n```\n\n```{python}\nscooter.iloc[3]\n```\n\n::: notes\nTo pick a specific column, like \"start time,\" we use brackets: bike_data['start_time']. For a single row, we use .iloc[], for example .iloc[3] for the third row. Currently, these start and end time columns are stored as plain text, not as real datetime objects, which limits what we can do with them.\n:::\n\n## Loading dates properly with `parse_dates`\n\n```{python}\nscooter = pd.read_csv(\n  \"data/scooter_sharing_data.csv\",\n  parse_dates=[\"start_time\", \"end_time\"]\n)\n\nprint(scooter.head(3))\n```\n\n```{python}\n#| eval: false\n# If parsing fails or columns weren’t parsed correctly, convert manually\n# Example: converting 'start_time' manually\nscooter[\"start_time\"] = pd.to_datetime(scooter[\"start_time\"], format=\"%Y-%m-%d %H:%M:%S\")\n```\n\n::: notes\nWe can instruct Pandas to parse certain columns as datetime during loading by adding the parse_dates argument to read_csv(). We pass a list of column names we want converted. This way, Pandas automatically detects and converts them into datetime objects. If that fails, we can use pd.to_datetime() and specify the format manually.\n:::\n\n## Checking the datetime conversion\n\n```{python}\n# Check the data types of columns\nprint(scooter.dtypes)\n```\n\n```{python}\n# Access the 'start_time' column for the first row\nprint(scooter.loc[0, \"start_time\"])\n```\n\n```{python}\n# Verify its type\nprint(type(scooter.loc[0, \"start_time\"]))\n```\n\n::: notes\nAfter loading with parse_dates, accessing the \"start_time\" for a row returns a Pandas Timestamp. This object behaves much like a Python datetime, letting us manipulate and analyze dates easily.\n:::\n\n## Calculating duration using datetime arithmetic\n\n```{python}\nscooter[\"duration\"] = scooter[\"end_time\"] - scooter[\"start_time\"]\nprint(scooter.head(5))\n```\n\n::: notes\nNow that start and end times are datetimes, we can subtract them to find the ride duration. For example, create a new column duration by subtracting start time from end time. The result is a timedelta object showing how long each ride lasted. Printing the first five rows shows durations like 4 minutes, 1 hour 30 minutes, and so forth.\n:::\n\n## Working with timedelta and method chaining\n\n::: notes\nPandas supports chaining methods for cleaner code. For example, to convert durations into total seconds, use .dt.total_seconds(). Writing it in multiple lines with backslashes helps readability. Viewing these converted values shows ride lengths in seconds instead of timedeltas — such as 240 seconds, 5400 seconds, etc.\n:::\n\n## Summarizing datetime data in Pandas\n\n::: notes\nToday, we’re going to explore how to summarize data in Pandas, focusing on datetime columns. Keep in mind, Pandas updates often, so some techniques might not work on very old versions. If you run into problems, make sure your Pandas is at least version 0.23.\n:::\n\n## Summarizing data in Pandas\n\n::: notes\nLet’s start with the basics of summarizing data in Pandas. For columns with numeric data, you can easily get averages with .mean(), medians with .median(), totals with .sum(), and more. For example, if we have a dataset of movie lengths, calling .mean() on the duration column might show the average movie length is about 102 minutes. Using .sum() could tell us the total runtime of all movies combined.\n:::\n\n## Summarizing data in Pandas with Python integration\n\n::: notes\nThe results from Pandas functions work smoothly with regular Python code. For instance, if you sum all movie runtimes and then divide by the total number of days in a year, you could find out how many hours of movies are watched daily on average. This blend makes Pandas very flexible for calculations.\n:::\n\n## Summarizing categorical data in Pandas\n\n::: notes\nFor columns with categories, like movie genres, you can count how often each genre appears using .value_counts(). Suppose we find 120 action movies and 80 comedies in our list. Dividing these counts by the total number of movies gives the percentage for each genre — for example, 60% action and 40% comedy.\n:::\n\n## Summarizing datetime in Pandas with duration conversion\n\n::: notes\nTo analyze time durations better, create a new column that converts duration into seconds. Pandas lets you group data easily using .groupby(). For example, grouping movies by genre and calculating the average duration in seconds reveals that action movies might last longer than comedies on average.\n:::\n\n## Grouping by time with resample\n\n::: notes\nYou can also group data by time intervals with .resample(). If we resample movie release dates by month, we might find that movies released in June average 110 minutes, while those in December average 95 minutes. This helps identify trends over time.\n:::\n\n## Other grouping methods in Pandas\n\n::: notes\nPandas provides more group operations like .size(), which counts items in each group, or .first(), which shows the first entry in each group. These are useful when you want quick summaries of grouped data.\n:::\n\n## Plotting grouped data with Pandas\n\n::: notes\nIt’s easy to visualize your summaries by adding .plot() to the end of your operations. Pandas uses Matplotlib behind the scenes and sets up decent default charts, but you can customize them if you want.\n:::\n\n## Spotting outliers by changing resampling frequency\n\n::: notes\nTry switching your resampling from monthly to daily intervals to spot unusual data points. For example, you might find one day where a movie screening lasted an extraordinary 10 hours — probably an error or special event. Seeing this alongside days with no screenings can provide useful context.\n:::\n\n## Additional datetime methods in pandas\n\n::: notes\nIn this last lesson, we’ll explore some more Pandas methods for handling dates and times. By the end, you’ll know how to work with timezones in Pandas and perform other common datetime tasks.\n:::\n\n## Timezones in pandas\n\n::: notes\nLet’s start by understanding why timezones matter. Imagine we calculate the shortest ride time in seconds using the dt.total_seconds() method combined with min(). We might get a negative value, like -2800 seconds, which doesn’t make sense because ride times can’t be negative.\n:::\n\n## Timezones in pandas\n\n::: notes\nThe issue, as seen before in regular Python, comes from Daylight Saving Time. These datetime values begin as timezone-naive, meaning they lack any timezone info or UTC offset. Let’s look at the first three ride start times to confirm this. Next, we’ll assign a timezone to these using dt.tz_localize(). After this, you’ll see that the dates now show a UTC offset.\n:::\n\n## Timezones in pandas\n\n::: notes\nIf we try converting the entire start time column to the Europe/London timezone, Pandas throws an AmbiguousTimeError. This happens because one timestamp falls during the Daylight Saving shift. Following the error message, we can set the ambiguous parameter in dt.tz_localize(). By default, this raises an error, but we can pass 'NaT' so Pandas marks the ambiguous time as Not a Time. Pandas will then ignore these NaT values in calculations like min().\n:::\n\n## Timezones in pandas\n\n::: notes\nWith the timezone issue fixed, we should recalculate ride durations to catch any that crossed Daylight Saving boundaries. Now, converting durations to seconds and finding the minimum gives us a reasonable 130.0 seconds, or a little over two minutes.\n:::\n\n## Timezones in pandas\n\n::: notes\nTo see what we fixed, let’s check the problematic row. Both its start and end times are now NaT due to ambiguity, so the duration is also NaT since it’s the difference between two undefined times.\n:::\n\n## Other datetime operations in pandas\n\n::: notes\nThere are more datetime operations worth knowing. The basics like extracting the year or month are available with dt.year, dt.month, and similar attributes. For instance, here are the years for the first three rides. Pandas also offers unique features, like dt.day_name(), which returns the weekday name for each datetime. You can even get these names in different languages. Using groupby(), you can summarize data by year, month, or day of the week.\n:::\n\n## Other parts of pandas\n\n::: notes\nPandas also allows shifting rows using the shift() method. For example, shifting ride data down by one row moves the original first row to the second position, and the first row becomes NaT. This helps if you want to compare each ride’s end time to the next ride’s start time. You’ll get a chance to practice this in an upcoming exercise.\n:::\n\n# Thank you\n\n::: notes\n\n:::","srcMarkdownNoYaml":"\n\n## Date in python\n\n::: notes\nWelcome to data science for everyone. Today I’ll be guiding you through this course on handling dates and times in Python. Dates are everywhere in data science—whether it's tracking stock market changes, running experiments, recording birthdays, or analyzing political events. All of these happen at specific points in time. Being able to work with time-based data is a fundamental skill for any data scientist.\n\nPython includes a special class for working with dates, called date. It’s similar to other data types like strings, numbers, or arrays—it has its own rules for how to create it and methods for using it. In this lesson, we’ll focus on how to create date objects and how to pull basic information from them.\n:::\n\n## Date in python\n\n```{python}\ndates = [\"12/03/2025\", \"11/05/2025\"]\n```\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nSo, why do we need a separate class just for dates? Let’s find out. In this chapter, you’ll work with 67 years of hurricane landfall data in Florida. You’ll start with a list called two_hurricanes, which includes the dates of two hurricanes stored as strings—one from October 7th, 2016, and another from June 21st, 2017. These dates follow the U.S. format: month, day, year.\n\nNow imagine trying to answer a few questions:\n\nHow many days passed between these two hurricanes?\n\nAre they listed in the correct chronological order?\n\nWhat day of the week did each one happen?\n\nDoing this manually would be tedious. But with Python, it’s simple. By the end of this chapter, you’ll know exactly how to do all of these things.\n:::\n\n## Creating date objects\n\n```{python}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\n```\n\n::: white-text\n-   How many days passed between these two dates?\n\n-   Are they listed in the correct chronological order?\n\n-   What are the days of the week?\n:::\n\n::: notes\nTo start working with dates, we first need to import the date class. All date and time-related classes live inside Python’s datetime module. We create a date using the date() function.\n\nHere’s how we turn our two hurricane dates into Python date objects. The date() function takes three arguments: year, month, and day—in that order. So for October 7, 2016, we write date(2016, 10, 7), and for June 21, 2017, we write date(2017, 6, 21). It’s a simple format: from largest to smallest—year, then month, then day.\n\nLater on, we’ll see how to convert strings into dates, but for now, we’ll stick to creating them manually or using pre-made lists.\n:::\n\n## Accessing date components\n\n```{python}\nfrom datetime import date\ndates = [date(2025, 3, 12), date(2025, 5, 11)]\nprint(dates[0].year)\nprint(dates[0].month)\nprint(dates[0].day)\n```\n\n::: notes\nOnce you have a date object, you can easily get its individual parts. Want the year? Just use .year. Need the month or day? Use .month and .day. It’s straightforward and easy to remember.\n:::\n\n## Finding the weekday\n\n```{python}\nprint(dates[0].weekday())\n```\n\n::: white-text\n0 = Monday 1 = Tuesday ... 6 = Sunday What are the days of the week?\n:::\n\n::: notes\nPython can also help with more complex tasks. For example, to find out what day of the week a date falls on, you can use the .weekday() method. This method returns a number from 0 to 6, where 0 is Monday, 1 is Tuesday, and so on—up to 6, which is Sunday. So if .weekday() returns 4, that means the date is a Friday.\n:::\n\n## Understanding date math\n\n```{python}\na = 21\nb = 24\nlist = [a, b]\nprint(max(list))\nprint(a - b)\nprint(a + 10)\n```\n\n::: notes\nToday, we’re going to explore how to do math with dates. That means things like figuring out how many days are between two dates, moving a date forward or backward, and comparing which date comes first. Let’s go back to something familiar: simple math with numbers. If we pick two numbers—say 21 and 24—we can use Python to figure out which one is smaller. We’ll store them as variables and place them into a list. Then, using the max() function, Python will return the smallest one. In our case, that’s 21. We can perform mathematical operations on the numbers as well.\n:::\n\n## Turning numbers into dates\n\n```{python}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\ndate2 = date(2025, 5, 11)\ndate_list = [date1, date2]\nprint(max(date_list))\n```\n\n::: notes\nNow let’s switch from numbers to dates. We’ll use the date class from Python’s datetime module. We create two date objects: one for each of these dates. We can then put these into a list and use the max() function again. This time, it tells us which date comes first.\n:::\n\n## Subtracting dates\n\n```{python}\ndate_sub = date2 - date1\ndate_sub.days\n```\n\n```{python}\ntype(date_sub)\n```\n\n::: notes\nJust like numbers, we can subtract one date from another. If we subtract March 10th from April 8th, Python gives us something called a timedelta object. This object tells us the difference between the two dates. If we check its .days attribute, we’ll see how many days are in between—in this case, 29.\n:::\n\n## Adding time to dates\n\n```{python}\nfrom datetime import timedelta\ntd = timedelta(days = 10)\nprint(date1 + td)\n```\n\n::: notes\nWe can also go the other way: we can add days to a date. To do that, we import timedelta, then create a 29-day time span. If we add that to March 10th, Python gives us April 8th. It takes care of counting the days in each month automatically—no need to remember how many days are in March!\n:::\n\n## The ISO 8601 format\n\n```{python}\nfrom datetime import date\ndate1 = date(2025, 3, 12)\nprint(date1) # ISO format (YYYY-MM-DD)\n```\n\n```{python}\nprint([date1.isoformat()])\n```\n\n::: notes\nPython makes it easy to turn date objects into strings that are easier to read or use. This is helpful when you want to display a date on the screen, include it in a file name, or save it in a CSV or Excel file. Let’s start with how Python shows a date by default. We'll import date from datetime and create a date for July 15, 2022. When we print this date, Python shows it like this: 2022-07-15. That’s year first, then month, then day — all separated by dashes. This format is known as ISO 8601. It's standardized, and always uses two digits for the month and day, even if they're below 10. If we want to get this date as a string — say, to save in a CSV file — we can use the .isoformat() method.\n:::\n\n## Why ISO 8601 is useful\n\n```{python}\ndates_list = [\"2001-09-25\", \"2003-02-10\"]\nprint(sorted(dates_list))\n```\n\n::: notes\nOne big advantage of ISO 8601 is that it sorts dates properly when they’re in string format. Let’s say we have two dates as strings: “2003-02-10” and “2001-09-25”. If we put them in a list and sort it, they’ll be ordered from oldest to newest. That’s because ISO 8601 format puts the biggest unit (year) first, followed by month and day. This makes it really useful for naming files in a way that keeps them in chronological order.\n:::\n\n## Other date formats\n\n```{python}\n#| eval: false\nd.strftime()\n```\n\n::: notes\nIf you don’t want to use the ISO format, Python gives you other options. You can use the strftime() method to format dates however you want.\n:::\n\n## Using `strftime` to format dates\n\n```{python}\ndate3 = date(2021, 4, 3)\nprint(date3.strftime(\"%Y\"))\nprint(date3.strftime(\"%m\"))\nprint(date3.strftime(\"The month is %m.\"))\nprint(date3.strftime(\"%m/%d/%Y\"))\nprint(date3.strftime(\"%Y-%j\")) # format 'YYYY-DDD'\nprint(date3.strftime(\"%B (%Y)\")) # format 'MONTH (YYYY)'\n```\n\n::: notes\nThe strftime() method lets you create a string version of a date using a format code. Let’s create a date for April 3, 2021. If we use strftime(\"%Y\"), Python gives us just the year: “2021”. You can include this in a longer string too — for example, \"Year: %Y\" would return \"Year: 2021\". There are more format codes too. %m gives you the month as a number, and %d gives you the day. So \"%m/%d/%Y\" would return something like \"04/03/2021\". You can combine these in any way you like to match the format you need.\n:::\n\n## Combining dates and times\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14)\n```\n\n::: notes\nSo far, we've only been working with dates. Now, it's time to bring in the concept of time — not just the day, but the hour, minute, and second within that day.\nLet’s look at an example: imagine something happened on March 14, 2022, at 3:45:10 PM. Instead of just storing the date, we want to include the exact time. Let’s see how we can represent this in Python.\nTo work with both dates and times, we need to import the datetime class from the datetime module. Yes, both are called “datetime.” It’s a bit confusing at first, but you’ll get used to it quickly.\nLet’s make a new datetime object and store it in a variable called dt. We’ll give it all the information it needs right when we create it.\nThe first three values we pass in are the same as when we create a date object — the year, followed by the month, then the day. All as numbers.\n:::\n\n## Adding the hour\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\n```\n\n::: notes\nAfter the day, we add the hour. Python uses 24-hour time by default, so 3 PM would be 15.\nNext, we enter the minutes — in this case, 45. Remember, there are 60 minutes in an hour.\nFinally, we include the seconds. So, for 10 seconds past the minute, we add 10 as the last argument. Our full datetime now includes all six parts: year, month, day, hour, minute, and second.\n:::\n\n## Including microseconds\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10, 250000)\n\n# explicit named arguments\ndt = datetime(year = 2022, month = 3, day = 14, \n              hour = 15, minute = 45, second = 10, \n              microsecond = 250000)\n```\n\n::: notes\nIf you need more precision, you can add microseconds. For example, adding 250,000 microseconds means the time is 0.25 seconds past 9:45:10. Python can track time down to millionths of a second — and if you need even more precision, like nanoseconds, we’ll cover that when we get to Pandas.\nThat's a lot to remember, so if it helps, you can use named arguments like year=2022, month=3, and so on. This makes your code easier to read and reduces the chance of mistakes.\n:::\n\n## Modifying a datetime\n\n```{python}\nprint(dt)\n```\n\n```{python}\ndt_new = dt.replace(minute = 22, microsecond = 500000)\nprint(dt_new)\n```\n\n::: notes\nYou can also take an existing datetime and tweak it using the replace() method. For example, if you want to round a time down to the start of the hour, you can set minutes, seconds, and microseconds to zero. This gives you a new datetime, with the other values unchanged.\n:::\n\n## Example dataset: City scooter trips\n\n::: notes\nFor the rest of this course, we’ll use data from a scooter sharing service in Austin, Texas. Each record shows when a scooter was unlocked and when it was returned. We'll focus on one scooter, ID “X13456,” and track all its trips in the last three months of 2022. Each trip has a start and end datetime — perfect for practicing with date and time data.\n:::\n\n## Printing and parsing datetimes\n\n```{python}\nfrom datetime import datetime\ndt = datetime(2022, 3, 14, 15, 45, 10)\nprint(dt.strftime(\"%Y-%m-%d\"))\n```\n\n```{python}\nprint(dt.strftime(\"%Y-%m-%d %H:%M:%S\"))\n```\n\n```{python}\nprint(dt.strftime(\"%Y-%m-%d %I:%M:%S %p\"))\n```\n\n::: notes\nJust like dates, datetimes can be displayed in many different ways. Python can also take a string and turn it into a datetime. Let’s first look at how to format and print a datetime, then move on to how Python can read one from a string.\nWe’ll start by creating a datetime for March 14, 2022, at 3:45:10 PM. To turn this into a nicely formatted string, we’ll use strftime().\n\nFirst, we’ll print just the date using %Y for the full year, %m for the month, and %d for the day.\n\nNext, we’ll include the time using %H for hour (24-hour format), %M for minutes, and %S for seconds.\n\nYou can also use codes for 12-hour time and add AM or PM if needed. To convert your datetime to a 12-hour format with AM/PM, you can use the format codes %I for the hour (12-hour clock) and %p for AM/PM\n:::\n\n## ISO 8601 format\n\n```{python}\nprint(dt.isoformat())\n```\n\n::: notes\nPython also has a built-in way to print a datetime in a standard format using isoformat().\n\nThis outputs the date and time as YYYY-MM-DDTHH:MM:SS, which is a widely accepted format and great to use when you’re unsure what format to pick.\n:::\n\n## Parsing datetimes with strptime\n\n```{python}\nfrom datetime import datetime\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m/%d/%Y %H:%M:%S\")\n```\n\n::: notes\nNow let’s turn a string into a datetime. This is useful when you get dates from text files, websites, or APIs.\n\nTo start, import the datetime class from the datetime module.\nThe function we’ll use is called strptime(), which means “string parse time.”\n\nIt takes two arguments: the string that contains the date and time, and a format string that tells Python how to read it.\nLet’s say we have a string like '10/12/2023 08:45:27'. That’s October 12, 2023 at 8:45:27 in the morning.\nNow we give Python the format it needs to understand the string.\n\nIn this case, the format would be '%m/%d/%Y %H:%M:%S'. This tells Python to expect a month, day, and year with slashes, followed by time separated by colons.\n\nUsually, once per dataset, you’ll figure out this format and reuse it.\n:::\n\n## Confirming the result\n\n```{python}\nprint(type(dt2))\n```\n\n```{python}\nprint(dt2)\n```\n\n::: notes\nIf we check the type of the result, it’s a datetime object.\n\nAnd if we print it, Python shows a clean version of the datetime — proving it was parsed correctly.\n:::\n\n## When formats don’t match\n\n```{python}\n#| error: true\nfrom datetime import datetime\n\n# Incorrect formatting\ndt2 = datetime.strptime(\"10/12/2023 08:45:27\",\n                        \"%m-%d-%Y %H:%M:%S\")\n```\n\n::: notes\nThe format must exactly match the string.\n\nIf you forget to include the time, or if there’s an extra comma or symbol in the string, Python will throw an error. Always check that your format and string align.\n:::\n\n## Working with Unix timestamps\n\n```{python}\ntimestamp = 2113441232.0\n\nprint(datetime.fromtimestamp(timestamp))\n```\n\n::: notes\nAnother common way to store datetimes is with Unix timestamps. These are just numbers counting seconds since January 1, 1970 — the \"start\" of time for most modern systems.\n\nTo convert a Unix timestamp to a datetime, use datetime.fromtimestamp(). This gives you a readable datetime.\n:::\n\n## Working with durations\n\n```{python}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0)\nend_datetime = datetime(2025, 8, 16, 17, 30, 0)\nduration = end_datetime - start_datetime\n```\n\n::: notes\nDatetime objects support arithmetic operations similar to dates. We can compare, add, or subtract time intervals from them. Since they include both dates and times, handling durations involves a bit more detail, but it’s straightforward once you understand the basics. Let’s dive in.\nTo understand durations better, imagine placing two datetime points on a timeline. These points mark the beginning and end of an event, like a car trip. Visualizing them helps clarify the elapsed time between these moments.\nIn Python, you can assign the starting and ending times to variables named start_datetime and end_datetime.” When you subtract “start” from “end,” you get a timedelta object, which measures the length of time that passed between the two.\n:::\n\n## Getting duration in seconds\n\n```{python}\nprint(duration.total_seconds())\n```\n\n::: notes\nBy calling the total_seconds() method on the timedelta, you find out exactly how many seconds passed. For example, if the timedelta shows 3720 seconds, that means the event lasted for 1 hour and 2 minutes.\n:::\n\n## Creating timedeltas manually\n\n```{python}\nfrom datetime import timedelta\nd1 = timedelta(seconds = 5)\n```\n\n::: notes\nYou can also build a timedelta from scratch by importing it from the datetime module. Just specify the amount of time you want, like one second or three minutes. For instance, d1 could represent a duration of 5 seconds.\n:::\n\n## Adding timedeltas to datetimes\n\n```{python}\nprint(start_datetime)\n```\n\n```{python}\nprint(start_datetime + d1)\n```\n\n::: notes\nIf you add d1 to a datetime variable, the result will be a new datetime that’s exactly that much later. So adding 5 seconds to “start” shifts the time forward by two seconds.\n:::\n\n## Making larger timedeltas\n\n```{python}\nfrom datetime import timedelta\nd2 = timedelta(days = 2, seconds = 5)\nprint(start_datetime + d2)\n```\n\n::: notes\nYou can make timedeltas of any size—days, hours, or even weeks. For example, d2 might be a duration of two days and five seconds. Adding delta2 to “start” moves the datetime ahead by that full amount. Timedeltas range from tiny microseconds to millions of years.\n:::\n\n## Using negative timedeltas\n\n```{python}\nd3 = timedelta(days = -2)\nprint(start_datetime + d3)\n```\n\n::: notes\nTimedeltas can also represent negative durations. If delta3 equals minus two days, adding it to “start” actually moves the datetime two days into the past.\n:::\n\n## Subtracting timedeltas\n\n```{python}\nd4 = timedelta(weeks = 2)\nprint(start_datetime - d4)\n```\n\n::: notes\nSubtracting a positive timedelta has the same effect as adding a negative one. For example, subtracting a two-week timedelta from “start” shifts the datetime back by two weeks, matching the result of adding a negative timedelta of the same length.\n:::\n\n## Understanding UTC offsets\n\n:::{.white-text}\n-  Naive datetime objects lack time zone information, making global time comparison inaccurate\n\n-  Historically, towns set clocks by local solar noon, causing slight time differences between nearby towns\n\n-  Small local time differences were insignificant before rapid travel and communication\n\n-  Trains and telegraphs highlighted the need for consistent regional timekeeping\n\n-  Governments standardized time zones across broad regions to unify clocks\n\n-  Example: New York follows Eastern Time within the U.S. time zone system\n\n-  Coordinated Universal Time (UTC) established in the UK as the global time reference\n\n-  Time zones are offsets from UTC: e.g., New York is UTC-4 (daylight savings), Tokyo is UTC+9\n:::\n\n::: notes\nSometimes you need to know the exact moment something happened. Until now, the datetime objects you've used are \"naive\" — meaning they don’t include any information about their time zone. Because of this, you can't accurately compare times from different parts of the world.\nBefore time zones existed, each town set its clock so that noon was when the sun was highest overhead locally.\nSo if another town 80 miles away did the same, its noon would be slightly different — maybe by 10 or 15 minutes. Back then, this small difference wasn’t a big deal.\nBut once trains and telegraphs allowed people and messages to move quickly over long distances, these small time differences caused confusion. People needed a consistent way to tell time across regions.\nTo fix this, governments agreed that all clocks within a broad area would follow the same time, even if that didn’t perfectly match the sun’s position. For example, the United States has several main time zones. The data we’ll use was recorded in New York, which follows Eastern Time.\nSince time no longer depends on the sun directly, how do we set our clocks? The answer lies with the United Kingdom, which created the first standard time reference called UTC (Coordinated Universal Time). Clocks worldwide are set based on UTC. Clocks west of the UK are behind UTC, and those east are ahead. For instance, New York is UTC-4 during daylight savings, while Tokyo is UTC+9.\n:::\n\n## Adding timezone info in code\n\n```{python}\nfrom datetime import datetime, timedelta, timezone\n\nny_timezone = timezone(timedelta(hours=-4))\n\n# Timezon aware\ncar_ride_start = datetime(2025, 8, 16, 15, 0, 0, tzinfo=ny_timezone)\n\nprint(car_ride_start)\n```\n\n::: notes\nLet’s jump into Python. We’ll import datetime, timedelta, and timezone. The timezone module lets us specify the time zone of our datetime objects, so they become \"aware\" of their offset from UTC.\nSuppose our car ride started at 3:00 PM in New York, which is UTC-4. We create a timezone object for UTC-4, then attach it to our datetime. When printed, this datetime now shows the UTC offset.\n:::\n\n## Converting between time zones\n\n```{python}\ntokyo_timezone = timezone(timedelta(hours=9))  # Tokyo (UTC+9)\n\n# Convert New York time to Tokyo time using astimezone()\ncar_ride_tokyo_time = car_ride_start.astimezone(tokyo_timezone)\nprint(\"Same moment in Tokyo time:\", car_ride_tokyo_time)\n```\n\n::: notes\nBeing timezone-aware means we can convert times easily. For example, to see what the car ride time would be in Tokyo (UTC+9), we create a Tokyo timezone object and use the astimezone() method. The time adjusts to show the same moment, but according to Tokyo’s clock.\n:::\n\n## Adjust timezone vs changing tzinfo\n\n```{python}\nprint(start_datetime)\n```\n\n```{python}\nprint(start_datetime.replace(tzinfo = timezone.utc))\n```\n\n```{python}\nprint(start_datetime.astimezone(timezone.utc))\n```\n\n::: notes\nFinally, there’s a key difference between changing the timezone with astimezone() and just swapping the timezone info directly with replace(). Using replace() only swaps the timezone label without adjusting the clock time. But astimezone() changes both the time and the offset so the moment stays correct globally.\n:::\n\n## Time zone basics\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n```\n\n::: notes\nNow that you know how UTC offsets work, let's move on to using time zones in real situations.\nThere’s a database called tz that's updated several times a year whenever time zone rules change. Many programming languages use this database. Because time zones change often, it’s better not to hard-code them into software like Python. Instead, we use a package called dateutil that taps into this database.\n:::\n\n## Creating a timezone object\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\n```\n\n::: notes\nLet's create a timezone object for the Pacific time zone in the United States. The tz database organizes time zones by continent, then by a major city. For example, 'America/Los_Angeles' is used for the U.S. west coast. We get this timezone by calling tz.gettz() with 'America/Los_Angeles'.\n:::\n\n## More examples of time zones\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\nla = tz.gettz('America/Los_Angeles')\ntk = tz.gettz('Asia/Tokyo')\npa = tz.gettz('Europe/Paris')\n```\n\n::: notes\nHere are a few others you might use: 'Asia/Tokyo', and 'Europe/Paris'\n:::\n\n## Applying time zones to data\n\n```{python}\nstart_datetime = datetime(2025, 8, 16, 9, 0, 0, tzinfo = la)\nprint(start_datetime)\n```\n\n```{python}\nend_datetime = datetime(2025, 8, 16, 17, 30, 0, tzinfo = la)\nprint(end_datetime)\n```\n\n::: notes\nLet's look at start_datetime again. Instead of manually adding the UTC offset, you apply the timezone object from tz. When you check the result, you’ll see it automatically includes the correct UTC offset.\nThe best part is that this timezone object updates the UTC offset depending on the date and time. For example, if you create a datetime for a ride in winter versus summer with the same timezone, the offset changes accordingly. We’ll cover daylight saving time soon, but basically, clocks shift twice a year in some regions. Instead of manually tracking these changes, tz handles it for you. It even knows historical changes going back decades. If you have data across many years, using tz helps keep all your timestamps consistent.\n:::\n\n## Starting daylight saving time\n\n::: notes\nSome regions adjust their clocks twice each year to enjoy longer evenings in summer. This adjustment is known as daylight saving time, though a better name might be daylight shifting. In some countries, it’s called “summer time.” Managing daylight saving time often complicates working with dates and times. To keep things simple, we'll first focus on when clocks move forward in spring. Later, we’ll cover what happens when clocks fall back in autumn.\n:::\n\n## Example of daylight saving time starting\n\n::: notes\nFor instance, on April 5, 2023, in New York City, the clock jumped from 1:59 am directly to 3:00 am. This means the clock “sprang forward,” skipping the entire 2 am hour. That hour never officially happened in New York on that day.\n:::\n\n## Changes in utc offset during daylight saving start\n\n::: notes\nTo compare New York’s time with other locations, we use a UTC offset. Before the shift, at 1 am on that day, New York was on Eastern Standard Time, which is UTC-5. After the jump, at 3 am, New York moved to Eastern Daylight Time, UTC-4. This means the offset changed by one hour forward.\n:::\n\n## Illustrating daylight saving time with code\n\n```{python}\nfrom datetime import datetime\n\n# Before DST jump\ndt1 = datetime(2023, 3, 12, 1, 59, 59)\n\n# This time jumps forward to 3:00 AM (2:00 AM skipped)\ndt2 = datetime(2023, 3, 12, 3, 0, 0)\n\nprint(\"dt1:\", dt1.isoformat())\nprint(\"dt2:\", dt2.isoformat())\n\n# Calculate the difference\ndiff = dt2 - dt1\nprint(\"Difference:\", diff)\nprint(\"Difference:\", diff.total_seconds())\n```\n\n::: notes\nLet’s demonstrate this in code. We create two datetime objects for April 5, 2023: one at 2:59:59 am without timezone info, and another at 3:00 am, also without timezone info. Printing their ISO format confirms the times. Subtracting them shows a difference of one hour and one second, matching the clock change.\n:::\n\n## Defining timezone offsets manually\n\n```{python}\nfrom datetime import datetime, timezone, timedelta\n\n# Define timezones manually\nEST = timezone(timedelta(hours=-5))  # Eastern Standard Time (UTC-5)\nEDT = timezone(timedelta(hours=-4))  # Eastern Daylight Time (UTC-4)\n\n# Create datetime objects with these timezones\ndt_est = dt1.replace(tzinfo=EST)\ndt_edt = dt2.replace(tzinfo=EDT)\n\nprint(\"dt_est:\", dt_est.isoformat())\nprint(\"dt_edt:\", dt_edt.isoformat())\n\n# Calculate the difference\ndiff = dt_edt - dt_est\nprint(\"Difference:\", diff)\n\n```\n\n::: notes\nTo handle timezone-aware datetime objects, we first define the timezones manually. We create an Eastern Standard Time object with a UTC offset of -5 hours and an Eastern Daylight Time object with a UTC offset of -4 hours.\nWe assign the 1:59 am timestamp to EST and check the ISO format to confirm the offset. Then, we assign the 3:00 am timestamp to EDT and verify its offset too. When subtracting these timezone-aware datetime objects, the difference correctly shows only one second, since the hour was skipped. Using UTC offsets helps us compare times accurately.\n:::\n\n## Automating timezone rules with dateutil\n\n```{python}\nfrom dateutil import tz\n\n# Get the timezone object for America/New_York\nny_tz = tz.gettz(\"America/New_York\")\n\n# Create timezone-aware datetime for 1:59 AM on April 5, 2023\ndt_before = datetime(2023, 4, 5, 1, 59, 0, tzinfo=ny_tz)\n\n# Create timezone-aware datetime for 3:00 AM on April 5, 2023\ndt_after = datetime(2023, 4, 5, 3, 0, 0, tzinfo=ny_tz)\n\nprint(\"Before DST change:\", dt_before, \"Offset:\", dt_before.utcoffset())\nprint(\"After DST change: \", dt_after, \"Offset:\", dt_after.utcoffset())\n\n```\n\n::: notes\nBut how can we know the exact moment clocks change without searching every time? The dateutil library helps here. Instead of manually defining timezones, we create a timezone object using dateutil’s tz.gettz(), specifying \"America/New_York.\" We then create timezone-aware datetime objects for 1:59 am and 3:00 am on April 5, 2023. Dateutil automatically assigns the correct offsets, recognizing the daylight saving change.\n:::\n\n## Ending daylight saving time\n\n\n\n::: notes\nLast time, we looked at what happens when clocks \"spring forward\" for daylight saving. Now, let's explore what occurs when clocks \"fall back\" in autumn. We’ll also explain how to handle events that happen during this repeated hour so there’s no confusion.\n:::\n\n## The repeated hour in daylight saving end\n\n::: notes\nImagine it’s October 29th, 2024, in New York City. At 2 AM, the clock turns back one hour to 1 AM again. This means there are two separate 1 AM times in a row. We can picture this by folding the timeline to show the hour happening twice.\n:::\n\n## Mapping the repeated hour to UTC\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\n\n# Time zone for New York\nny_tz = tz.gettz(\"America/New_York\")\nutc_tz = tz.UTC\n\n# First 1:00 AM (before the fall back, during DST)\nfirst_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to DST\nfirst_1am_local = first_1am_local.replace(fold=0)\nfirst_1am_utc = first_1am_local.astimezone(utc_tz)\n\n# Second 1:00 AM (after the fall back, standard time)\nsecond_1am_local = datetime(2024, 11, 3, 1, 0, 0, tzinfo=ny_tz)\n# Disambiguate to Standard Time\nsecond_1am_local = second_1am_local.replace(fold=1)\nsecond_1am_utc = second_1am_local.astimezone(utc_tz)\n\n# Print the results\nprint(\"First 1:00 AM NY (DST):       \", first_1am_local)\nprint(\"First 1:00 AM in UTC:         \", first_1am_utc)\nprint()\nprint(\"Second 1:00 AM NY (Standard): \", second_1am_local)\nprint(\"Second 1:00 AM in UTC:        \", second_1am_utc)\n```\n\n::: notes\nTo understand this, we convert everything to UTC. The first 1 AM corresponds to 5 AM UTC, because New York is 4 hours behind UTC during daylight saving. At 1:59:59 AM local time, it’s 5:59:59 AM UTC. Then the clock resets back to 1 AM, but time keeps moving forward in UTC. Now New York is 5 hours behind UTC, so the second 1 AM equals 6 AM UTC.\n:::\n\n## Working with ambiguous times in Python\n\n```{python}\nfrom datetime import datetime\nfrom dateutil import tz\nfrom dateutil.tz import datetime_ambiguous\n\n# Timezone for example (Europe/London ends DST on Oct 29, 2023 at 2 AM)\ntz_london = tz.gettz(\"Europe/London\")\n\n# Create a datetime during the DST fall-back transition\nambiguous_time = datetime(2023, 10, 29, 1, 0, 0, tzinfo=tz_london)\n\n# Check if it's ambiguous\nis_ambiguous = datetime_ambiguous(ambiguous_time)\nprint(\"Is 1:00 AM on Oct 29 ambiguous in London?\", is_ambiguous)\n```\n\n::: notes\nLet’s create a timezone object for our data. We make a datetime for October 29th at 1 AM. We check if this time is ambiguous — meaning it could happen twice — and find that it is. Next, we make another datetime at the same date and time but mark it as the second 1 AM using a special \"fold\" function. This tells Python which 1 AM we mean.\n:::\n\n## What fold means and why UTC matters\n\n```{python}\n# First 1 AM (DST)\nfirst_1am = ambiguous_time.replace(fold=0)\nfirst_utc = first_1am.astimezone(tz.UTC)\n\n# Second 1 AM (Standard Time)\nsecond_1am = ambiguous_time.replace(fold=1)\nsecond_utc = second_1am.astimezone(tz.UTC)\n\n# Display both versions and their UTC equivalents\nprint(\"\\nFirst 1:00 AM (DST):       \", first_1am)\nprint(\"First 1:00 AM in UTC:      \", first_utc)\n\nprint(\"\\nSecond 1:00 AM (Standard): \", second_1am)\nprint(\"Second 1:00 AM in UTC:     \", second_utc)\n\n# Duration between the two in UTC\nduration = second_utc - first_utc\nprint(\"\\nTime difference in UTC:\", duration)\n```\n\n::: notes\nThe \"fold\" flag by itself doesn’t change how Python calculates time differences. Python ignores it during arithmetic unless you specifically handle it. To avoid confusion, we convert times to UTC, which has no repeats. Doing this, Python correctly shows that the two 1 AM times are one hour apart. So, to accurately measure time over daylight saving changes, always do calculations in UTC.\nWe’ve seen how to handle clocks moving forward and backward, using both manual offsets and timezone-aware libraries. Python sometimes ignores daylight saving differences, which is fine in many cases. But if you need precise results, set timezone info properly and convert to UTC for comparisons and duration calculations.\n:::\n\n## Reading date and time data in Pandas\n\n```{python}\nimport pandas as pd\n\nscooter = pd.read_csv(\"data/scooter_sharing_data.csv\")\nprint(scooter.head(3))\n```\n\n::: notes\nIn this section, we'll explore how to handle date and time data using the Pandas library. If you've worked with Pandas before, this will build on that by introducing datetime data types.\nLet's begin by importing Pandas as pd. We'll load a CSV file named \"scooter_sharing_data.csv\" using pd.read_csv(). The data is saved into a variable called scooter. To get a quick look, we'll print out the first three rows.\nYou'll notice the index starts at zero on the far left. The table is wide, so it might wrap lines. Each row contains fields like start time, end time, start location, end location, bike ID, and the user type — whether they are a subscriber or a casual rider.\n:::\n\n## Selecting columns and rows in Pandas\n\n```{python}\nscooter['start_time']\n```\n\n```{python}\nscooter.iloc[3]\n```\n\n::: notes\nTo pick a specific column, like \"start time,\" we use brackets: bike_data['start_time']. For a single row, we use .iloc[], for example .iloc[3] for the third row. Currently, these start and end time columns are stored as plain text, not as real datetime objects, which limits what we can do with them.\n:::\n\n## Loading dates properly with `parse_dates`\n\n```{python}\nscooter = pd.read_csv(\n  \"data/scooter_sharing_data.csv\",\n  parse_dates=[\"start_time\", \"end_time\"]\n)\n\nprint(scooter.head(3))\n```\n\n```{python}\n#| eval: false\n# If parsing fails or columns weren’t parsed correctly, convert manually\n# Example: converting 'start_time' manually\nscooter[\"start_time\"] = pd.to_datetime(scooter[\"start_time\"], format=\"%Y-%m-%d %H:%M:%S\")\n```\n\n::: notes\nWe can instruct Pandas to parse certain columns as datetime during loading by adding the parse_dates argument to read_csv(). We pass a list of column names we want converted. This way, Pandas automatically detects and converts them into datetime objects. If that fails, we can use pd.to_datetime() and specify the format manually.\n:::\n\n## Checking the datetime conversion\n\n```{python}\n# Check the data types of columns\nprint(scooter.dtypes)\n```\n\n```{python}\n# Access the 'start_time' column for the first row\nprint(scooter.loc[0, \"start_time\"])\n```\n\n```{python}\n# Verify its type\nprint(type(scooter.loc[0, \"start_time\"]))\n```\n\n::: notes\nAfter loading with parse_dates, accessing the \"start_time\" for a row returns a Pandas Timestamp. This object behaves much like a Python datetime, letting us manipulate and analyze dates easily.\n:::\n\n## Calculating duration using datetime arithmetic\n\n```{python}\nscooter[\"duration\"] = scooter[\"end_time\"] - scooter[\"start_time\"]\nprint(scooter.head(5))\n```\n\n::: notes\nNow that start and end times are datetimes, we can subtract them to find the ride duration. For example, create a new column duration by subtracting start time from end time. The result is a timedelta object showing how long each ride lasted. Printing the first five rows shows durations like 4 minutes, 1 hour 30 minutes, and so forth.\n:::\n\n## Working with timedelta and method chaining\n\n::: notes\nPandas supports chaining methods for cleaner code. For example, to convert durations into total seconds, use .dt.total_seconds(). Writing it in multiple lines with backslashes helps readability. Viewing these converted values shows ride lengths in seconds instead of timedeltas — such as 240 seconds, 5400 seconds, etc.\n:::\n\n## Summarizing datetime data in Pandas\n\n::: notes\nToday, we’re going to explore how to summarize data in Pandas, focusing on datetime columns. Keep in mind, Pandas updates often, so some techniques might not work on very old versions. If you run into problems, make sure your Pandas is at least version 0.23.\n:::\n\n## Summarizing data in Pandas\n\n::: notes\nLet’s start with the basics of summarizing data in Pandas. For columns with numeric data, you can easily get averages with .mean(), medians with .median(), totals with .sum(), and more. For example, if we have a dataset of movie lengths, calling .mean() on the duration column might show the average movie length is about 102 minutes. Using .sum() could tell us the total runtime of all movies combined.\n:::\n\n## Summarizing data in Pandas with Python integration\n\n::: notes\nThe results from Pandas functions work smoothly with regular Python code. For instance, if you sum all movie runtimes and then divide by the total number of days in a year, you could find out how many hours of movies are watched daily on average. This blend makes Pandas very flexible for calculations.\n:::\n\n## Summarizing categorical data in Pandas\n\n::: notes\nFor columns with categories, like movie genres, you can count how often each genre appears using .value_counts(). Suppose we find 120 action movies and 80 comedies in our list. Dividing these counts by the total number of movies gives the percentage for each genre — for example, 60% action and 40% comedy.\n:::\n\n## Summarizing datetime in Pandas with duration conversion\n\n::: notes\nTo analyze time durations better, create a new column that converts duration into seconds. Pandas lets you group data easily using .groupby(). For example, grouping movies by genre and calculating the average duration in seconds reveals that action movies might last longer than comedies on average.\n:::\n\n## Grouping by time with resample\n\n::: notes\nYou can also group data by time intervals with .resample(). If we resample movie release dates by month, we might find that movies released in June average 110 minutes, while those in December average 95 minutes. This helps identify trends over time.\n:::\n\n## Other grouping methods in Pandas\n\n::: notes\nPandas provides more group operations like .size(), which counts items in each group, or .first(), which shows the first entry in each group. These are useful when you want quick summaries of grouped data.\n:::\n\n## Plotting grouped data with Pandas\n\n::: notes\nIt’s easy to visualize your summaries by adding .plot() to the end of your operations. Pandas uses Matplotlib behind the scenes and sets up decent default charts, but you can customize them if you want.\n:::\n\n## Spotting outliers by changing resampling frequency\n\n::: notes\nTry switching your resampling from monthly to daily intervals to spot unusual data points. For example, you might find one day where a movie screening lasted an extraordinary 10 hours — probably an error or special event. Seeing this alongside days with no screenings can provide useful context.\n:::\n\n## Additional datetime methods in pandas\n\n::: notes\nIn this last lesson, we’ll explore some more Pandas methods for handling dates and times. By the end, you’ll know how to work with timezones in Pandas and perform other common datetime tasks.\n:::\n\n## Timezones in pandas\n\n::: notes\nLet’s start by understanding why timezones matter. Imagine we calculate the shortest ride time in seconds using the dt.total_seconds() method combined with min(). We might get a negative value, like -2800 seconds, which doesn’t make sense because ride times can’t be negative.\n:::\n\n## Timezones in pandas\n\n::: notes\nThe issue, as seen before in regular Python, comes from Daylight Saving Time. These datetime values begin as timezone-naive, meaning they lack any timezone info or UTC offset. Let’s look at the first three ride start times to confirm this. Next, we’ll assign a timezone to these using dt.tz_localize(). After this, you’ll see that the dates now show a UTC offset.\n:::\n\n## Timezones in pandas\n\n::: notes\nIf we try converting the entire start time column to the Europe/London timezone, Pandas throws an AmbiguousTimeError. This happens because one timestamp falls during the Daylight Saving shift. Following the error message, we can set the ambiguous parameter in dt.tz_localize(). By default, this raises an error, but we can pass 'NaT' so Pandas marks the ambiguous time as Not a Time. Pandas will then ignore these NaT values in calculations like min().\n:::\n\n## Timezones in pandas\n\n::: notes\nWith the timezone issue fixed, we should recalculate ride durations to catch any that crossed Daylight Saving boundaries. Now, converting durations to seconds and finding the minimum gives us a reasonable 130.0 seconds, or a little over two minutes.\n:::\n\n## Timezones in pandas\n\n::: notes\nTo see what we fixed, let’s check the problematic row. Both its start and end times are now NaT due to ambiguity, so the duration is also NaT since it’s the difference between two undefined times.\n:::\n\n## Other datetime operations in pandas\n\n::: notes\nThere are more datetime operations worth knowing. The basics like extracting the year or month are available with dt.year, dt.month, and similar attributes. For instance, here are the years for the first three rides. Pandas also offers unique features, like dt.day_name(), which returns the weekday name for each datetime. You can even get these names in different languages. Using groupby(), you can summarize data by year, month, or day of the week.\n:::\n\n## Other parts of pandas\n\n::: notes\nPandas also allows shifting rows using the shift() method. For example, shifting ride data down by one row moves the original first row to the second position, and the first row becomes NaT. This helps if you want to compare each ride’s end time to the next ride’s start time. You’ll get a chance to practice this in an upcoming exercise.\n:::\n\n# Thank you\n\n::: notes\n\n:::"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"brand":{"light":{"brand":{"color":{"palette":{"navy":"#2D3047","green":"#2F9D72","blue":"#2572B2","yellow":"#CBBA44","orange":"#F57E5D","purple":"#58508D","light_gray":"#E2E4E6","dark_gray":"#9DA3A7","charcoal":"#434A4F","black":"#000000"},"background":"charcoal","foreground":"orange","primary":"green"},"typography":{"fonts":[{"family":"Open Sans","source":"google"},{"family":"Open Sans","source":"google"},{"family":"Fira Code","source":"google"}],"base":"Open Sans","headings":"Open Sans","monospace":{"family":"Fira Code","size":"0.6em"},"monospace-inline":{"family":"Fira Code","size":"1.0em"}}},"data":{"color":{"palette":{"navy":"#2D3047","green":"#2F9D72","blue":"#2572B2","yellow":"#CBBA44","orange":"#F57E5D","purple":"#58508D","light_gray":"#E2E4E6","dark_gray":"#9DA3A7","charcoal":"#434A4F","black":"#000000"},"background":"charcoal","foreground":"orange","primary":"green"},"typography":{"fonts":[{"family":"Open Sans","source":"google"},{"family":"Open Sans","source":"google"},{"family":"Fira Code","source":"google"}],"base":"Open Sans","headings":"Open Sans","monospace":{"family":"Fira Code","size":"0.6em"},"monospace-inline":{"family":"Fira Code","size":"1.0em"}}},"brandDir":"/home/insane/Documents/date_time_python/brand","projectDir":"/home/insane/Documents/date_time_python","processedData":{"color":{"navy":"#2D3047","green":"#2F9D72","blue":"#2572B2","yellow":"#CBBA44","orange":"#F57E5D","purple":"#58508D","light_gray":"#E2E4E6","dark_gray":"#9DA3A7","charcoal":"#434A4F","black":"#000000","background":"#434A4F","foreground":"#F57E5D","primary":"#2F9D72"},"typography":{"base":"Open Sans","headings":"Open Sans","monospace":{"family":"Fira Code","size":"0.6em"},"monospace-inline":{"family":"Fira Code","size":"1.0em"},"monospace-block":{"family":"Fira Code","size":"0.6em"}},"logo":{"images":{}}}}}},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","highlight-style":"dracula","output-file":"date_time_python.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.7.33","auto-stretch":true,"title":"Handling date time in pythonn","jupyter":"python3","brand":"brand/_dsfe_brand.yml","height":1080,"width":1920,"slideNumber":true,"theme":"theme/dsfe_theme.scss","code-copy":false,"logo":"logo/dsfe_logo.svg","footer":"Data Science For Everyone"}}},"projectFormats":[]}