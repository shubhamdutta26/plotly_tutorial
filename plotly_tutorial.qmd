---
title: "Plotly tutorial"
format:  
  revealjs:
    slide-number: true
    theme: theme/dsfe_theme.scss
    code-copy: false
    output-location: column
    code-line-numbers: false
revealjs-plugins:
  - detective
jupyter: python3
highlight-style: "dracula"
brand: brand/_dsfe_brand.yml
execute:
  echo: true
---

## Plotly

-  Basics
-  Customization
-  Annotations
-  Subplots
-  Layering
-  Buttons

::: notes
Hello everyone. Welcome to Data Science for everyone. Today I am going to teach you interactive visualizations using Plotly in Python.

I will start with the basics of plotly, the move on to customization and annotations, I will show you how to make subplots with layering and I will end by showing you how to place buttons on your plots—let's get started!
:::

# Basics

## A simple bar plot

```{python}
import plotly.express as px
```

::: notes
Let me start by showing you how to make a simple bar plot. We'll import plotly express using the standard alias 'px'.
:::

## A simple bar plot

:::{.detective data-detective-search="days, sleep_hours"}
```{python}
import plotly.express as px

days = ["Mon", "Tue", "Wed"]
sleep_hours = [8, 5, 10]
```
:::

::: notes
I have created two lists here: days and sleep hours corresponding to the days.
:::

## A simple bar plot

:::{.detective data-detective-search="bar"}
```{python}
#| eval: false
import plotly.express as px

days = ["Mon", "Tue", "Wed"]
sleep_hours = [8, 5, 10]

fig = px.bar(


)
```
:::

::: notes
To make a simple bar plot we will call the function bar.
:::

## A simple bar plot

:::{.detective data-detective-search="x, y"}
```{python}
#| eval: false
import plotly.express as px

days = ["Mon", "Tue", "Wed"]
sleep_hours = [8, 5, 10]

fig = px.bar(
  x = days, 
  y = sleep_hours
)
```
:::

::: notes
Inside bar we will specify x and y arugments mapped to days and sleep hours respectively.
:::

## A simple bar plot

:::{.detective data-detective-search="fig.show"}
```{python}
import plotly.express as px

days = ["Mon", "Tue", "Wed"]
sleep_hours = [8, 5, 10]

fig = px.bar(
  x = days, 
  y = sleep_hours
)
fig.show()
```
:::

::: notes
As soon as we call fig.show the plot is displayed. And just like that a few simple lines of code gives us a bar chart in plotly.
:::

## Adding a title

:::{.detective data-detective-search="title"}
```{python}
import plotly.express as px

days = ["Mon", "Tue", "Wed"]
sleep_hours = [8, 5, 10]

fig = px.bar(
  x = days, 
  y = sleep_hours, 
  title = "Hours of sleep"
)
fig.show()
```
:::

::: notes
To add a title to the plot, we can call the title argument and place our desired title in quotes.
:::

## A `pandas` dataframe

:::{.detective data-detective-search="DataFrame"}
```{python}
#| eval: false
import pandas as pd

sleep = pd.DataFrame({
  

})
```
:::

::: notes
A pandas dataframe can also be used in plotly. Let me show you how. We first need to import pandas as standard alias pd. Then we call the dataframe function and name it as sleep.
:::

## A `pandas` dataframe

:::{.detective data-detective-search="DataFrame"}
```{python}
#| eval: false
import pandas as pd

sleep = pd.DataFrame({
  "day": ["Mon", "Tue", "Wed"],
  "sleep_hours": [8, 5, 10]
})
```
:::

::: notes
We add two columns: day and sleep hours and include to list with each with the relevant contents as before.
:::

## A `pandas` dataframe

:::{.detective data-detective-search="data_frame"}
```{python}
import pandas as pd

sleep = pd.DataFrame({
  "day": ["Mon", "Tue", "Wed"],
  "sleep_hours": [8, 5, 10]
})

fig = px.bar(
  data_frame = sleep,
  x = days, 
  y = sleep_hours, 
  title = "Hours of sleep"
)
fig.show()
```
:::

::: notes
To use this dataframe inside plotly, we need to use an agrument called data underscore frame and the rest is the same as before.
:::

## Inside a `plotly` figure {.smaller}

```{python}
#| output-location: default
print(fig)
```

::: notes
Let's peek under the hood to understand how Plotly structures its figures. Every figure has two core components. First is layout—this dictionary holds all the styling attributes like fonts, colors, and axis properties. Each figure has exactly one layout. Next is data—this is actually a list of dictionaries that sets up the type of graph and the data to display. where each entry defines a trace. The combination of data and type is called a trace. One can have multiple traces per plot. We will look at traces later in the tutorial.
:::

## Plotly is interactive

![](images/buttons.png)

::: notes
Every plot we create automatically comes with built-in interactive features. When we hover over any data point, a tooltip pops up showing the exact values. There are buttons on the top right hand side of each plot tha let us download your plot as a static image, zoom into specific regions, pan around, select data points, and even toggle between different view modes. All of this functionality is included by default—we don't have to write a single extra line of code.
:::

# Univariate visualizations

::: notes
Now that we have learnt some basics of plotly lets look at Univariate visualization. Univariate visualizations are visualizations on datasets that have one variable. Lets focus on two most common plots types for univariate data visualizations. The first is a histogram.
:::

## A histogram

```{python}
#| echo: false
iris = pd.read_csv("data/iris.csv")
fig = px.histogram(
  data_frame = iris,
  x = "Petal.Length",
)
fig.show()
```

::: notes
Histograms might look a lot like bar charts at first glance, but they group numeric values into ranges, called bins. Each bar shows how many data points fall inside a particular interval, and the bar height can represent counts or other summaries like sums or averages. Lets look at an example.
:::

## A histogram

:::{.detective data-detective-search="read_csv"}
```{python}
#| output-location: default
iris = pd.read_csv("data/iris.csv")
print(iris.head())
```
:::

::: notes
Lets bring in the iris dataset. We will use the read csv function from pandas. The iris dataset contains sepal and petal lengths of three different species of iris flowers. The link to the data is in the description below.
:::

## A histogram

:::{.detective data-detective-search="histogram"}
```{python}
iris = pd.read_csv("data/iris.csv")

fig = px.histogram(
  data_frame = iris,
  x = "Petal.Length",
)
fig.show()
```
:::

::: notes
To make a histogram we need to use the histogram function. Inside we pass in the DataFrame, pick the column we want on the x-axis; in this case petal lengths. Calling fig.show generates the histogram.
:::

## Adjusting bin size

:::{.detective data-detective-search="nbins"}
```{python}
iris = pd.read_csv("data/iris.csv")

fig = px.histogram(
  data_frame = iris,
  x = "Petal.Length", 
  nbins = 20
)
fig.show()
```
:::

::: notes
There are a few handy options we can pass to the histogram function to customize how it behaves. For example, we can change the number of bins using the nbin argument. I have set the nbins to 20.If you want even more control over binning and appearance, the Plotly online documentation is a great place to explore further. We will look at customization later in the tutorial.
:::

## Box plots

![](images/boxplot.png)

::: notes
Another common visualization plot for univariate data is boxplot. A boxplot squeezes a lot of distribution information into a compact shape. The main box spans from the first quartile up to the third quartile, showing the middle 50% of the data, with a line in the middle that marks the median. The whiskers extend toward the lower and upper values, but they typically stop before extreme points, which show up as separate dots and are treated as potential outliers based on a standard rule involving the interquartile range.
:::

## Box plots

:::{.detective data-detective-search="box"}
```{python}
fig = px.box(
  data_frame = iris,
  y = "Sepal.Width",
)
fig.show()
```
:::

::: notes
Let’s draw a box plot for sepal width using Plotly. The function box takes our DataFrame and the column to plot, which we’ll feed into the y argument to get a vertical box. This gives a quick visual summary of typical petal lengths, the spread of the data, and any sepal that look unusually short or long.
:::

## Adding points with boxplot

:::: {.columns}

::: {.column width="50%"}

:::{.detective data-detective-search="points"}
```{python}
#| eval: false
#| output-location: default
fig = px.box(
  data_frame = iris,
  y = "Sepal.Width",
  points="all"
)
fig.show()
```
:::

:::

::: {.column width="50%"}
![](images/box_1.png)
:::

::::

::: notes
Box plots also come with some useful options to add more context. With the points argument set to all, we can include a point plot beside the boxplot. Hovering mouse over these points tells us value of each sepal width. But there is an issue. The iris dataset contains three species of iris flowers. Hovering over each point shows us the sepal width but not the species. Lets fix that.
:::

## Adjust hover data

:::: {.columns}

::: {.column width="50%"}

:::{.detective data-detective-search="hover_data"}
```{python}
#| eval: false
#| output-location: default
fig = px.box(
  data_frame = iris,
  y = "Sepal.Width",
  points="all",
  hover_data=["Species"]
)
fig.show()
```
:::

:::

::: {.column width="50%"}
![](images/box_2.png)
:::

::::

::: notes
With the hover_data argument, we can include extra columns such as species so that hovering over a point reveals the corresponding species or other details. As we can see I have set the hover data argument to species. Now if we hover our mouse over any point it gives us the species name along with the sepal width values.
:::

## Boxplots

:::{.detective data-detective-search="x, Species"}
```{python}
fig = px.box(
  data_frame = iris,
  x = "Species",
  y = "Sepal.Width"
)
fig.show()
```
:::

::: notes
Setting x argument to Species we can brake down the boxplot into three species of iris flowers. We can see versicolor species has the smallest sepal widths among the three.
:::

# Customizing colors

::: notes
So far we have looked at univariate visualizations. Soon we will look at bivariate plots. But before lets look at how we can use colors in our plots.
:::

## Adding color scales

```{python}
#| echo: false
sleep = pd.DataFrame({
  "day": days,
  "sleep_hours": sleep_hours
})
```

:::{.detective data-detective-search="color"}
```{python}
fig = px.bar(
  data_frame = sleep,
  x = "day", 
  y = "sleep_hours", 
  color = "day"
)
fig.show()
```
:::

::: notes
Here we are looking at a bar plot we made at the beginning which tracks sleep hours for three days of the week. We have added a color argument and set it to day which will color each bar based on the day. Just like that we can add colors to our plots. Plotly automatically assigns a unique color to every category in that column, or generates a gradient scale if the column is numerical. But we can customize color scales however we want.
:::

## Customize color scales

:::{.detective data-detective-search="color_discrete_map"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color_discrete_map={
    "Mon": "rgb(0, 0, 255)",
    "Tue": "rgb(0, 255,0)",
    "Wed": "rgb(255, 0, 0)"
  },
  color = "day"
)
fig.show()
```
:::

::: notes
To do this, we use color_discrete_map argument. The color_discrete_map helps us set color for discrete categories. This argument expects a Python dictionary where keys match the data categories, and values are the specific colors we want. Here the data categories are days of the week, Mon, Tue, and Wed and the colors are set using the rgb strings. Here I have set them to blue, green, and red.
:::

## Customize color scales

:::{.detective data-detective-search="my_colors"}
```{python}
my_colors = {
    "Mon": "rgb(0, 0, 255)",
    "Tue": "rgb(0, 255,0)",
    "Wed": "rgb(255, 0, 0)"
  }
```
:::

::: notes
We can also make the color dictionary separately. Here i have created the same dictionary and named it my colors.
:::

## Customize color scales

:::{.detective data-detective-search="color_discrete_map, my_colors"}
```{python}
my_colors = {
    "Mon": "rgb(0, 0, 255)",
    "Tue": "rgb(0, 255,0)",
    "Wed": "rgb(255, 0, 0)"
  }
fig = px.box(
  data_frame=px.data.iris(),
  x = "species",
  y = "petal_length",
  title = "Hours of sleep",
  color_discrete_map=my_colors,
  color = "species"
)
fig.show()
```
:::

::: notes
I have used this dictionary inside the box plot. So far we have looked at colors to map discrete variables. What if we are dealing with numbers instead of categories?
:::

## Preset colors {.smaller}

:::{.detective data-detective-search="color_continuous_scale"}
```{python}
fig = px.bar(
  data_frame = sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color_continuous_scale = "Viridis",
  color = "sleep_hours"
)
fig.show()
```
:::

::: notes
For this, we use the color_continuous_scale argument. This lets us apply smooth gradients rather than distinct categories. Plotly has fantastic built-in library of colors. Let's color our chart by sleep_hours using the "Viridis" scale. It maps low sleep hour values to dark purple which is Tuesday and high sleep hour values to bright yellow which is Wednesday. You can find a huge list of these named scales in the plotly documentation online.
:::

## Customize color scales {.smaller}

:::{.detective data-detective-search="custom_color, color_continuous_scale"}
```{python}
custom_color = [
  ("rgb(0, 0, 255)"),
  ("rgb(0, 255,0)"),
  ("rgb(255, 0, 0)")
]
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color_continuous_scale = custom_color,
  color = "sleep_hours"
)
fig.show()
```
:::

::: notes
We can also make the color dictionary separately and use it with the color_continuous_scale argument.
:::

# Bivariate visualizations

::: notes
Now lets look at bivariate visualizations. Bivariate visualizations are visualizations on two variables. Lets focus on a couple of most common plots types for bivariate data visualizations. The first is a scatter plot.
:::

## Scatter plots

:::{.detective data-detective-search="scatter"}
```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length"
)
fig.show()
```
:::

:::notes
Scatter plots relies on a Cartesian system: we have an X-axis representing our first variable and a Y-axis for the second. Wherever those two values meet for a single data point, a marker is placed. For instance, here we have a scatter plot using the scatter function that looks at sepal and petal lengths of iris flowers. From this scatter plot we can conclude that as sepal length increases so does the respective petal lengths.
:::

## Symbols

:::{.detective data-detective-search="symbol"}
```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  symbol="Species"
)
fig.show()
```
:::

::: notes
Plotly lets you customize scatter plots even further. We can map a categorical column to the 'symbol' argument. This changes the dots into squares or diamonds depending on the category. I have set it to the species.
:::

## Adding colors with symbols

:::{.detective data-detective-search="symbol, color"}
```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  symbol="Species",
  color="Species"
)
fig.show()
```
:::

::: notes
We can set the color values as well. I have set it to species along with the symbol argument. This plot has iris species mapped to both color and symbols.
:::

## Scatter plot with `trendline`

:::{.detective data-detective-search="trendline, ols"}
```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  symbol="Species",
  color="Species",
  trendline = "ols"
)
fig.show()
```
:::

::: notes
We can overlay scatter plots with trendlines. Trendlines could be linear or non-linear in nature. Here we have used ols or ordinary least squares trendline which is a linear regression line. Other types of trendlines could be use as well such as lowess or moving averages.
:::

## Line plot

:::{.detective data-detective-search="line"}
```{python}
stocks = pd.read_csv("data/stocks.csv")

fig = px.line(
  data_frame = stocks,
  x = "Date",
  y = "MSFT"
)
fig.show()
```
:::

::: notes
The second type of bivariate plot is a line plot. These are your go-to for tracking changes over time. Line plots are simple to make using the line function in plotly. Here we are looking microsoft stocks from the stocks dataset. The x axis is set to date and y axis is set to the stock value over time.
:::


## Correlation plot


::: notes
Now, what if you want to check relationships between many variables at once? That is where correlation plots come in. For correlation plots we need a statistical parameter called the Correlation Coefficient. Ideally, it gives us a number between negative one and positive one. Explain correlation coefficient and corr function.
:::


## Correlation plot

:::{.detective data-detective-search="drop"}
```{python}
#| eval: false
#| output-location: default
# Remove species column from iris dataset
iris_2 = iris.drop("Species", axis = 1)
```
:::

::: notes
Let's analyze a iris dataset. We want to see how petal and sepal length and widths relate to each other. The dataframe must have all numerical variables and no categorical variable. The iris dataset has one categorical variable called species. We have to remove that column first. To do that we will use the drop  function and set axis argument to 1. This removes the Species column.
:::

## Correlation plot

:::{.detective data-detective-search="corr"}
```{python}
#| output-location: default
# Remove species column from iris dataset
iris_2 = iris.drop("Species", axis = 1)

iris_corr = iris_2.corr(method="pearson")

print(iris_corr)
```
:::

::: notes
We don't plot the raw data immediately; first, we create a correlation matrix using the corr function. We will set the method to pearson which is one of the most common correlation coefficient. This generates a grid of numbers ranging from -1 to +1 showing how strong the relationship is for every pair of variables.
:::

## Correlation plot

:::{.detective data-detective-search="imshow"}
```{python}
fig = px.imshow(
  iris_corr,
)
fig.show()
```
:::

::: notes
Numbers in a grid can be hard to read, so let's visualize it with a heatmap using the function called imshow. We pass our new correlation matrix into it. And we get a correlation matrix plot.
:::

## Correlation plot

:::{.detective data-detective-search="text_auto"}
```{python}
fig = px.imshow(
  iris_corr,
  text_auto=True,
)
fig.show()
```
:::

::: notes
Setting text_auto to True displays the actual numbers in the boxes.
:::

## Correlation plot

:::{.detective data-detective-search="color_continuous_scale"}
```{python}
fig = px.imshow(
  iris_corr,
  text_auto=True,
  color_continuous_scale="RdYlGn"
)
fig.show()
```
:::

::: notes
We can also customize colors by setting a diverging color scale, like Red-to-Yellow-to-Green using the RdYlGn preset color variable.
:::

## Correlation plot

:::{.detective data-detective-search="zmin, zmax"}
```{python}
fig = px.imshow(
  iris_corr,
  text_auto=True,
  color_continuous_scale="RdYlGn",
  zmin = -1, zmax = 1
)
fig.show()
```
:::

::: notes
Additionally we can fixed the min-max values to -1 and 1 using the zmax and zmin arguments, ensuring proper color representation of correlation strength.
:::

# Customizing plots

::: notes
If you guys are still with me please like and subsribe to my channel. It helps me a lot. Next we’re going to level up our visualizations by mastering the art of interaction. We are diving into how to customize those pop-up hover details and fine-tune our chart legends to tell a better story.
:::

## Hover information

:::: {.columns}

::: {.column width="50%"}

```{python}
#| eval: false
#| output-location: default
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length"
)
fig.show()
```

:::

::: {.column width="50%"}
![](images/box_3.png)
:::

::::

::: notes
Lets take a look at this scatter plot. Hovering our mouse on any of these points we can look at the respective sepal and petal lengths. However we dont know which species the points represent.
:::

## Hover information

:::: {.columns}

::: {.column width="50%"}

:::{.detective data-detective-search="hover_data"}
```{python}
#| eval: false
#| output-location: default
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  hover_data=["Species"]
)
fig.show()
```
:::

:::

::: {.column width="50%"}
![](images/box_4.png)
:::

::::

::: notes
By setting the hover data argument to species we can now see the species information as well along with the respective sepal and petal lengths. This is pretty neat. But we can do more.
:::

## Customize hover information

:::{.detective data-detective-search="update_layout"}
```{python}
#| eval: false
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  hover_data=["Species"]
)

fig.update_layout(



)
fig.show()
```
:::

::: notes
To further customize hover information we will need to use the update_layout function. Let me demonstrate. We have our scatter plot and we will call the update_layout function.
:::

## Customize hover information

:::: {.columns}

::: {.column width="50%"}

:::{.detective data-detective-search="hoverlabel"}
```{python}
#| eval: false
#| output-location: default
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  hover_data=["Species"]
)

fig.update_layout(
  hoverlabel=dict(
    bgcolor="white",
    font_size=16,
    font_family="Rockwell"
  )
)
fig.show()
```
:::

:::

::: {.column width="50%"}
![](images/box_5.png)
:::

::::

::: notes
We can style the hover labels using the hoverlabel argument. This takes a dictionary where we can tweak things like the font family, background color, or border. There is a more complex method called hovertemplate for full HTML control which you will be able to find in the online documentation of plotly.
:::

# Legends

::: notes
Now let's look at legends. A legend is essentially the plot key—it decodes the symbols or colors we're using. If we color-code our plot, Plotly is smart enough to generate a legend automatically.
:::

## Plot legend

```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  symbol="Species",
  color="Species"
)
fig.show()
```

::: notes
Lets look at this plot. As you can see plotly automatically creates legend based on color and symbol mapped to individual species for the iris dataset. The legend is placed outside the plot. Let me show you how to bring it inside the plot.
:::

## Style plot legend

:::{.detective data-detective-search="my_legend"}
```{python}
my_legend = dict(
  x=0.2,
  y=0.95, 
  bgcolor="rgb(240, 229, 111)"
)
```
:::

::: notes
First we create a legend dictionary called my_legend.
:::

## Style plot legend

:::{.detective data-detective-search="x, y, bgcolor"}
```{python}
my_legend = dict(
  x=0.2,
  y=0.95, 
  bgcolor="rgb(240, 229, 111)"
)
```
:::

::: notes
To position it, we use the legend dictionary with x and y coordinates. These aren't pixels; they are normalized coordinates between 0 and 1. We can also set a background color. As always, the documentation has a full list of properties that you can look at.
:::

## Style plot legend

:::{.detective data-detective-search="showlegend, legend"}
```{python}
my_legend = dict(
  x=0.2,
  y=0.95, 
  bgcolor="rgb(240, 229, 111)"
)

fig.update_layout(
  showlegend=True, 
  legend=my_legend
)
fig.show()
```
:::

::: notes
As before we can use the update_layout function to modify the legend properties. We can also turn the legends on or off using the showlegend argument.
:::

# Annotations

::: notes
Now lets talk about Annotations. Annotations are bits of text you place directly on top of your figure to add context or highlight something important.
:::

## Adding annotations

- `add_annotation`
- `update_layout`

::: notes
In Plotly, there are two main ways to add annotations. You can attach them one by one with the add_annotation method, or you can set them all at once through update_layout using the annotations argument, which expects a list of annotation dictionaries. In this lesson, the focus will stay on update_layout, because it keeps all of the layout-related pieces—titles, axes, and annotations—in one place.
:::

## Arrows

```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)
```

::: notes
Lets look at this bar plot. Lets say we want to hightlight the bar with the least sleep hours which is on Tuesday.
:::

## Arrows

:::{.detective data-detective-search="less, showarrow, arrowhead"}
```{python}
less = dict(
    x="Tue", y=5, 
    text="Less sleep",
    font=dict(color="black"), 
    showarrow=True, arrowhead=4
)
```
:::

::: notes
To that end, we will create a dictionary called less and inside we will set the position of the annotations using x and y argument, add text using the text argument along with the font color. We will also tell plotly to draw an arrow to point to the annotation using the showarrow and arrowhead arguments.
:::

## Arrows {.smaller}

:::{.detective data-detective-search="annotations"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(annotations=[less])

fig.show()
```
:::

::: notes
Now we can update our plot using the annotations argument which takes a list of annotations. In our case we only have one annotation named less.
:::

## Multiple annotations

:::{.detective data-detective-search="more"}
```{python}
less = dict(
    x="Tue", y=5, 
    text="Less sleep",
    font=dict(color="black"), 
    showarrow=True, arrowhead=4
)

# Create the second annotation
more = dict(
    x="Wed", y=10, 
    text="More sleep",
    font=dict(color="black"), 
    showarrow=True, arrowhead=4,
)
```
:::

::: notes
We can add multiple annotations as well. Here in addition to the first annotation we have created a second annotation called more which will point to the day with the most number of sleep hours.
:::

## Multiple annotations {.smaller}

:::{.detective data-detective-search="less, more"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(annotations=[less, more])

fig.show()
```
:::

::: notes
To display both annotations we will add both less and more to the list. As you can see it is very simple to add annotations to plotly charts.
:::

## Annotations texts

:::{.detective data-detective-search="text, showarrow"}
```{python}
h_sleep = 8
msg = dict(
  x="Tue", y=9,
  text=f"Mon: {h_sleep} hours",
  font=dict(
    size=20, 
    color="white"
  ),
  bgcolor="rgb(237, 64, 200)", 
  showarrow=False
)
```
:::

::: notes
Here is another example of annotation text but this time without an arrow. I have made other modifications as you can see. For example I have used a fstring for the annotation text. I have also added a background color.
:::

## Annotations texts {.smaller}

:::{.detective data-detective-search="annotations"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(annotations = [msg])

fig.show()
```
:::

::: notes
This is what the annotation text looks like on the bar plot.
:::

## Annotations texts

:::{.detective data-detective-search="xref, yref"}
```{python}
h_sleep = 8
msg = dict(
  x=0.5, y=0.5, 
  xref="paper", yref="paper",
  text=f"Mon: {h_sleep} hours",
  font=dict(
    size=20, 
    color="white"
  ),
  bgcolor="rgb(237, 64, 200)", 
  showarrow=False
)
```
:::

::: notes
By default, x and y for an annotation are in data units, so the label moves with that point on the axes. If instead we set xref and yref arguments to 'paper', Plotly switches to a normalized coordinate system where 0 is one edge of the plotting area and 1 is the opposite edge. As you can see I have used x=0.5 and y=0.5 which is the center of the plot.
:::

## Annotations texts {.smaller}

```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(annotations = [msg])

fig.show()
```
::: notes
This places the text right in the middle of the plot region, independent of the underlying data values.
:::

# Axes customization

::: notes
Now lets move on to axis customization and transformation.
:::

## Axis labels {.smaller}

:::{.detective data-detective-search="update_xaxes, update_yaxes"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_xaxes(title_text="Day")
fig.update_yaxes(title_text="Time (hours)")

fig.show()
```
:::

::: notes
For this walkthrough, we will look at the sleep bar plot. The data is tidy enough for analysis, but the column names are still a bit “raw” and not ideal for a polished chart. Lets fix them. We will use update_xaxes and update_yaxes functions to rename the x and y axes respectively. These functions has an argument called title_text that can be used to modify axes labels.
:::

## Axis labels {.smaller}

:::{.detective data-detective-search="update_layout, xaxis, yaxis"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(dict(
  xaxis=dict(title = dict(text="Day")),
  yaxis=dict(title = dict(text="Time (hours)"))
))

fig.show()
```
:::

::: notes
We can also use the update_layout function to rename our axes. It takes a dictionary of x and yaxis titles as shown here.
The update_layout pattern is handy, because you can control several visual elements of the figure from one place.
:::

## Axis limits {.smaller}

:::{.detective data-detective-search="tickangle, range"}
```{python}
fig = px.bar(
  data_frame=sleep,
  x = "day", 
  y = "sleep_hours", 
  title = "Hours of sleep",
  color = "day"
)

fig.update_layout(dict(
  xaxis=dict(
    title = dict(text="Day"),
    tickangle=-30
  ),
  yaxis=dict(
    title = dict(text="Time (hours)"),
    range = [4, 15]
  )
 )
)

fig.show()
```
:::

::: notes
The axis limits along with several other properties can be customized using the update_layout function. Here I have angled x axis tick labels using the tickangle argument. And I have modified the range of the y axis from 4 to 15.
:::

## Axis transformation

:::{.detective data-detective-search="log_y"}
```{python}
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  color="Species",
  log_y= True
)

fig.show()
```
:::

::: notes
Lets look at axis transformation. There are several ways to transform axes. Here I am transforming the y axes to log by setting the log_y argument to true.
:::

# Subplots

::: notes
Next, lets learn how to create subplots. Think of a subplot as a dashboard. Instead of showing a single chart in isolation, we create a grid. This allows us to place multiple visualizations side-by-side. 
:::

## Subplots {.smaller}

:::{.detective data-detective-search="plotly.subplots, make_subplots"}
```{python}
import plotly.express as px
from plotly.subplots import make_subplots
```
:::

::: notes
To create subplots, we will need to import the make subplots package from plotly.subplots.
:::

## Create a grid {.smaller}

```{python}
import plotly.express as px
from plotly.subplots import make_subplots

fig = make_subplots(rows=2, cols=1)
```

::: notes
Next we call the make subplots function to create a grid. We can set up a 2-by-2 grid, a 1-by-3, or really any configuration we need. Just remember, the more panels we add, the smaller each one gets. Here we are creating a grid of 2 rows and 1 column.
:::

## Trace {.smaller}

```{python}
#| output-location: default
fig = px.scatter(
  data_frame = iris,
  x = "Sepal.Length",
  y = "Petal.Length",
  color="Species")
fig.data
```

::: notes
Before we build the grid, we need a quick refresher on 'traces' which I had discussed in the beginning of this video. In Plotly, a 'trace' is the actual drawing—the line, the bar, or the scatter points inside the figure. It holds the data and the style instructions. If we inspect a figure’s structure using the .data attribute, you get a tuple of these trace objects. We can grab them individually using index zero, index one, and so on. This is crucial because when we build subplots, we use the .add_trace() command to manually place these objects into specific slots on our grid
:::

## Subplots {.smaller}

::: fragment
:::{.detective data-detective-search="histogram, box"}
```{python}
import plotly.express as px
from plotly.subplots import make_subplots

fig = make_subplots(rows=2, cols=1)

hist = px.histogram(
  data_frame = iris, x='Petal.Length'
)

box = px.box(
 data_frame = iris, x='Petal.Length'
)
```
:::
:::

::: notes
Now that we understand trace, lets make two plots. First, we import plotly.express and make_subplots. We initialize our canvas with two rows and a single column. Now, we generate two separate charts:  One is a histogram and the other is a box plot. These are stored in hist and box variables respectively. These exist as independent figures right now.
:::

## Subplots {.smaller}

:::{.detective data-detective-search="add_trace, data"}
```{python}
import plotly.express as px
from plotly.subplots import make_subplots

fig = make_subplots(rows=2, cols=1)

hist = px.histogram(
  data_frame = iris, x='Petal.Length'
)

box = px.box(
 data_frame = iris, x='Petal.Length'
)

fig.add_trace(hist.data[0], row=1, col=1)
fig.add_trace(box.data[0], row=2, col=1)

fig.show()
```
:::

::: notes
To merge them, we use add_trace to pull the trace from the histogram using .data[0] and insert it into row one. We do the same for the second figure, which is the box plot, placing it in row two.  Now we have a vertical dashboard showing the petal lengths in two different ways.
:::

## Stacked subplots {.smaller}

```{python}
fig = make_subplots(
    rows=3, cols=1,
    subplot_titles=\
      ['Setosa', 'Versicolor', 'Virginica']
)
```

::: notes
Now let's try something more advanced. Suppose we want to separate plot for each iris flower species: setosa, versicolor, and virginica. Instead of writing code three times, we set up a grid with 3 row and 1 columns. For individual subplot titles we input a list of the three species to the subplot titles argument. We loop through our list of star types, filter the dataframe for that specific star, and generate a scatter plot. Inside the loop, we add that scatter trace to the correct column. It works, but notice how the axes are all scaled differently? It makes direct comparison pretty tricky."
:::

## Stacked subplots {.smaller}

```{python}
fig = make_subplots(
    rows=3, cols=1,
    subplot_titles=\
      ['Setosa', 'Versicolor', 'Virginica']
)

row_num = 1

for species in\
   ['setosa', 'versicolor', 'virginica']:
   # Filter individual species
    df = iris[iris['Species'] == species]
    # Make separate scatter plots
    scatter = px.scatter(
      df, x='Petal.Length', y='Sepal.Length'
    )
    # Add trace
    fig.add_trace(
      scatter.data[0], 
      row=row_num, 
      col=1
    )
    row_num += 1

fig.show()
```

::: notes
Then, We loop through our list of iris species, filter the dataframe for that specific species and store it in the variable df and generate separate scatter plots for each species. Inside the loop, we add that scatter trace to the correct row by incrementing the row_num value. And we get a nice scatter plot. One thing to note is the x-axes are all scaled differently. This makes direct comparison difficult. Lets fix this.
:::

## Shared axes {.smaller}

:::{.detective data-detective-search="shared_xaxes"}
```{python}
fig = make_subplots(
    rows=3, cols=1,
    subplot_titles=\
      ['Setosa', 'Versicolor', 'Virginica'],
    shared_xaxes=True
)

row_num = 1

for species in\
   ['setosa', 'versicolor', 'virginica']:
    df = iris[iris['Species'] == species]
    scatter = px.scatter(
      df, x='Petal.Length', y='Sepal.Length'
    )
    fig.add_trace(
      scatter.data[0], 
      row=row_num, 
      col=1
    )
    row_num += 1

fig.show()
```
:::

::: notes
To do this, we can lock the axes together. When we initialize the grid, we simply add the argument shared_xaxes=True. This forces every plot in the row to use the exact same vertical scale. Now, when we look at the plot we can see that petal length of setosa is much smaller compared to the other two species.
:::

# Layering

::: notes
Now that we understand subplots, we will look at layering. This is different from making subplots where charts sit next to each other in a grid. Here, we are talking about superimposing different graphs on the exact same canvas. To make this happen, we rely on the add_trace() function, which we have covered before.
:::

## Layering plots

:::{.detective data-detective-search="plotly.graph_objects, Figure"}
```{python}
#| output-location: default
from plotly.graph_objects import Figure

weather = pd.read_csv("data/weather.csv")
print(weather.head())
```
:::

::: notes
For layering we will import figure from plotly.graph_objects. We will use a new dataset called weather which contains temperatures of three cites in the US.
:::

## Layering plots

:::{.detective data-detective-search="plotly.graph_objects, Figure"}
```{python}
#| output-location: default
scatter_fig = px.scatter(
  weather, 
  x='DATE', y='Boston'
)

line_fig = px.line(
  weather, 
  x='DATE', y='Houston',
  color_discrete_sequence=['green']
)
```
:::

::: notes
Next we generate two plots: one is a scatter plot for Boston and the other is a line plot for Houston.
:::

## Layering plots

:::{.detective data-detective-search="Figure"}
```{python}
#| output-location: default
combined_fig = Figure(data=[*scatter_fig.data, *line_fig.data])
combined_fig.update_layout(title='USA city temperatures')
```
:::

::: notes
Finally, we fuse them together by creating a new combined figure that unpacks the data from both the scatter and line charts using the star operator.
:::

## Adding more layers

```{python}
#| output-location: default
line_fig_seattle = px.line(
  weather, 
  x='DATE', y='Seattle',
  color_discrete_sequence=['orange']
)
```

::: notes
We don't always have to build everything at once. Sometimes we might have an existing chart and we want to add a new metric onto it later. Lets add the seattle weather to our figure. As always we make a new line chart with the seattle weather.
:::

## Adding more layers

:::{.detective data-detective-search="add_trace"}
```{python}
#| output-location: default
combined_fig.add_trace(line_fig_seattle.data[0])
combined_fig.update_layout(title='USA city temperatures')
```
:::

::: notes
Then we use the add_trace function to add the seattle plot to our preexisting figure. Finally we will use the update layout function to generate the new figure.
:::

# Buttons

::: notes
With that we move to the last part of our tutorial on plotly. Lets learn how to add interactivity to our plots by using buttons.
:::

## Time buttons

![](images/google.png)

::: notes
Time buttons can be added to line charts to filter or zoom in on a specific time slice. We can see common time buttons on most stock websites, like this chart showing the stock prices for google. For example, 1D shows data for the last day, 1M for the previous month, 1Y for the last year, and YTD shows the year-to-date.
:::

## Time buttons in Plotly

-  `label` = Text on the button the user clicks on

. . .

-  `count` = How many steps to take
-  `step` = time period (month, day, year)

. . .

-  `stepmode`:
    +  `todate` = start of the next full time period
    +  `backward` = moves back by the `count`

::: notes
Technically speaking, a button in Plotly is just a Python dictionary with four main ingredients. First, we need a label, which is simply the text the user clicks on. Then we have count and step, which work together to define the duration—like taking "1" step of a "year". Finally, there is stepmode. This one is the secret sauce. It controls exactly how the timeline snaps into place using either 'backward' or 'todate'.
:::

## Creating date buttons {.smaller}

```{python}
#| output-location: default
date_buttons = [
  {'label': "6MTH", 'count': 6, 'step': "month", 'stepmode': "todate"},
]
```

::: notes
Lets create a button. Here were are creating a 6 month botton. We specify the label, count to 6 and step to month. We set the stepmode to 'todate' which means that it will snap the range to the final six months.
:::

## Creating date buttons {.smaller}

```{python}
#| output-location: default
date_buttons = [
  {'label': "6MTH", 'count': 6, 'step': "month", 'stepmode': "todate"},
  {'label': "6WTD", 'count': 6, 'step': "day",   'stepmode': "backward"},
  {'label': "YTD",  'count': 1, 'step': "year",  'stepmode': "todate"}
]
```

::: notes
Here I have created two more buttons. One for 6 days backward in time and the other is year to date. Lets see how we can integrate these buttons to our plot.
:::

## Creating date buttons {.smaller}

```{python}
#| output-location: default
date_buttons = [
  {'label': "6MTH", 'count': 6, 'step': "month", 'stepmode': "todate"},
  {'label': "6WTD", 'count': 6, 'step': "day",   'stepmode': "backward"},
  {'label': "YTD",  'count': 1, 'step': "year",  'stepmode': "todate"}
]

fig = px.line(
  weather, 
  x='DATE',
  y='Boston'
)
```

::: notes
We first generate our line plot with the weather data for Boston from the weather data.
:::

## Creating date buttons

:::{.detective data-detective-search="rangeselector"}
```{python}
#| output-location: slide
#| echo: false
fig.update_layout(dict(
    xaxis=dict(
      rangeselector=dict(buttons=date_buttons)
    )))

fig.show()
```
:::

::: notes
Now we merge the buttons and the plot together. To inject the buttons, we access the update_layout method. Inside there, we target the xaxis and specifically the rangeselector property. We simply pass our list of button dictionaries into the buttons argument, and Plotly handles the rendering logic for us.
:::

# Thank you

::: notes
Thats it. With that we come to the end of our tutorial on plotly. Please like, comment and subscribe to my channel if you are learning from my videos. See you in the next one.
:::